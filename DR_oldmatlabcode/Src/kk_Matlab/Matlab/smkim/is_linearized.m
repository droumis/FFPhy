function bool = is_linearized(linearized)
%IS_LINEARIZED Validate whether the input is a linearized estimate struct array.
%
%   IS_LINEARIZED(LINEARIZED) returns true if LINEARIZED is a struct array of
%   the type returned by a LINEARIZE_* function.
%   
%   See also LINEARIZE_UTRACK
%
%Written by SMK 2009 June 22.
%

% Is there some way to access the original mpeg video frames?
REQUIRED_FIELDS = { ...
    'subject'             , ...
    'day'                 , ...
    'epoch'               , ...
    'environment'         , ...
    'timestamp'           , ...
    'x_projection'        , ...
    'y_projection'        , ...
    'position' , ...
    'speed'    , ...
    'arrests'             , ...
    'units'               , ...
    'params'              , ...
    'transform'           };

if isempty(linearized) && isstruct(linearized) && ...
    all(isfield(linearized,REQUIRED_FIELDS))
  warning('HEADTRACK struct is empty');
  bool = true;

elseif ~isstruct(linearized) || ~all(isfield(linearized,REQUIRED_FIELDS))
  warning('missing required field(s)');
  bool = false;

elseif ~iscellstr({linearized(:).subject}) || ...
    ~all(strcmp({linearized(:).subject}, ...
    regexp({linearized(:).subject},'[a-zA-Z0-9]*','match','once')))
  warning(['subject field must be a string containing characters ' ...
      '[a-zA-Z0-9]']);
  bool = false;

elseif ~all(cellfun(@isnumeric,{linearized(:).day})) || ...
    ~all(cellfun(@isscalar,{linearized(:).day})) || ...
    ~all(cellfun(@isreal,{linearized(:).day})) || ...
    ~all(cellfun(@isfinite,{linearized(:).day})) || ...
    ~all(cellfun(@(c) (c >= 0),{linearized(:).day})) || ...
    ~all(cellfun(@(c) (round(c) == c),{linearized(:).day}))
  warning('day field must be a real non-negative integer scalar');
  bool = false;

elseif ~iscellstr({linearized(:).epoch}) || ...
    ~all(strcmp({linearized(:).epoch}, ...
    regexp({linearized(:).epoch},'[a-zA-Z0-9]*','match','once')))
  warning(['epoch field must be a string containing characters ' ...
      '[a-zA-Z0-9]']);
  bool = false;

elseif ~iscellstr({linearized(:).environment}) || ...
    ~all(strcmp({linearized(:).environment}, ...
    regexp({linearized(:).environment},'[a-zA-Z0-9]*','match','once')))
  warning(['environment field must be a string containing characters ' ...
      '[a-zA-Z0-9]']);
  bool = false;

elseif ~all(cellfun(@isnumeric,{linearized(:).timestamp})) || ...
    ~all(cellfun(@(c) isa(c,'uint32'),{linearized(:).timestamp})) || ...
    ~all(cellfun(@isvector,{linearized(:).timestamp})) || ...
    ~all(cellfun(@(c) (size(c,2) == 1),{linearized(:).timestamp})) || ...
    ~all(cellfun(@(c) isreal(c),{linearized(:).timestamp})) || ...
    ~all(cellfun(@(c) all(diff(c) > 0),{linearized(:).timestamp}))
  warning(['timestamp field must be a column vector of strictly ' ...
      'monotonically increasing real uint32 timestamps']);
  bool = false;

elseif ~all(cellfun(@isnumeric,{linearized(:).x_projection})) || ...
    ~all(cellfun(@(c) isa(c,'single'),{linearized(:).x_projection})) || ...
    ~all(cellfun(@isvector,{linearized(:).x_projection})) || ...
    ~all(cellfun(@(c) (size(c,2) == 1),{linearized(:).x_projection})) || ...
    ~all(cellfun(@(c) isreal(c),{linearized(:).x_projection}))
  warning('x_projection field must be a column vector of single reals');
  bool = false;

elseif ~all(cellfun(@isnumeric,{linearized(:).y_projection})) || ...
    ~all(cellfun(@(c) isa(c,'single'),{linearized(:).y_projection})) || ...
    ~all(cellfun(@isvector,{linearized(:).y_projection})) || ...
    ~all(cellfun(@(c) (size(c,2) == 1),{linearized(:).y_projection})) || ...
    ~all(cellfun(@(c) isreal(c),{linearized(:).y_projection}))
  warning('y_projection field must be a column vector of single reals');
  bool = false;

elseif ~all(cellfun(@isnumeric,{linearized(:).position})) || ...
    ~all(cellfun(@(c) isa(c,'single'),{linearized(:).position})) || ...
    ~all(cellfun(@isvector,{linearized(:).position})) || ...
    ~all(cellfun(@(c) (size(c,2) == 1),{linearized(:).position})) || ...
    ~all(cellfun(@(c) isreal(c),{linearized(:).position}))
  warning('position field must be a column vector of single reals');
  bool = false;

elseif ~all(cellfun(@isnumeric,{linearized(:).speed})) || ...
    ~all(cellfun(@(c) isa(c,'single'),{linearized(:).speed})) || ...
    ~all(cellfun(@isvector,{linearized(:).speed})) || ...
    ~all(cellfun(@(c) (size(c,2) == 1),{linearized(:).speed})) || ...
    ~all(cellfun(@(c) isreal(c),{linearized(:).speed}))
  warning('speed field must be a column vector of single reals');
  bool = false;

elseif ~all(cellfun(@is_timerange,{linearized(:).arrests}))
  warning('arrests field must be a N-by-2 matrix of uint32 timestamp intervals');
  bool = false;

elseif ~all(arrayfun(@(s) isequal( ...
    size(s.timestamp),size(s.position),size(s.speed),...
    size(s.x_projection),size(s.y_projection)),linearized))
  warning(['timestamp, position, speed, ' ...
      'x_projection, y_projection fields must all agree in size']);
  bool = false;

elseif ~iscellstr({linearized(:).units}) || ...
    ~all(cellfun(@(c) any(strcmp(c,{'cm','centimeter','centimeters'})), ...
    {linearized(:).units}))
  warning(['units field must be a string containing characters ' ...
      '[a-zA-Z0-9]']);
  bool = false;

else
  [i1, i2] = ndgrid(1:numel(linearized));
  pair_idx = find(i1 ~= i2);
  i1 = i1(pair_idx);
  i2 = i2(pair_idx);
  % Check that no two elements of linearized duplicate the same
  % (subject, day, epoch) 3-tuple
  if any(arrayfun(@(s1,s2) isequal( ...
      {s1.subject, s1.day, s1.epoch}, ...
      {s2.subject, s2.day, s2.epoch}),linearized(i1),linearized(i2)))
    bool = false;
  % Check that no two elements of linearized which share the same 
  % (subject, day) 2-tuple have overlapping timestamps
  elseif any( arrayfun(@(s1,s2) isequal( ...
      {s1.subject, s1.day},{s2.subject, s2.day}), ...
      linearized(i1),linearized(i2)) & ...
      arrayfun(@(s1,s2) ...
      ~(all(s1.timestamp < min(s2.timestamp)) || ...
      all(s1.timestamp > max(s2.timestamp))), ...
      linearized(i1),linearized(i2)) )
    bool = false;
  else
    bool = true;
  end

end

