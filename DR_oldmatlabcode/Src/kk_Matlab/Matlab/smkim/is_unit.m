function bool = is_unit(unit)
%IS_UNIT Validate whether the input is a unit struct array
%
%   IS_UNIT(UNIT) returns true if UNIT is a struct array that
%   contains valid unitly-recorded voltage data.
%   
%   See also READ_UNIT, written by smk.
%
%Written by SMK 2009 June 22.
%

% Number of channels per tetrode
NCHANNELS = 4;

REQUIRED_FIELDS = { ...
    'uid'                     , ...
    'subject'                 , ...
    'day'                     , ...
    'epoch'                   , ...
    'environment'             , ...
    'timerange'               , ...
    'tetrode'                 , ...
    'depth'                   , ...
    'hemisphere'              , ...
    'region'                  , ...
    'reference'               , ...
    'passbands'               , ...
    'thresholds'              , ...
    'Fs'                      , ...
    'samples_before_trigger'  , ...
    'amplitude_cutoff'        , ...
    'timestamp'               , ...
    'samples'                 , ...
    'clustnum'                , ...
    'shape'                   , ...
    'cluster_quality'         , ...
    'sources'                 };

if isempty(unit) && isstruct(unit) && ...
    all(isfield(unit,REQUIRED_FIELDS))
  warning('UNIT struct is empty');
  bool = true;
  return;

elseif ~isstruct(unit) || ~all(isfield(unit,REQUIRED_FIELDS))
  warning('missing required field(s)');
  bool = false;

elseif ~iscellstr({unit(:).uid}) || ...
    ~all(strcmp({unit(:).uid}, ...
    regexp({unit(:).uid},'[a-zA-Z0-9_]*','match','once')))
  warning(['uid field must be a string containing characters ' ...
      '[a-zA-Z0-9_]']);
  bool = false;

elseif ~iscellstr({unit(:).subject}) || ...
    ~all(strcmp({unit(:).subject}, ...
    regexp({unit(:).subject},'[a-zA-Z0-9]*','match','once')))
  warning(['subject field must be a string containing characters ' ...
      '[a-zA-Z0-9]']);
  bool = false;

elseif ~all(cellfun(@isnumeric,{unit(:).day})) || ...
    ~all(cellfun(@isscalar,{unit(:).day})) || ...
    ~all(cellfun(@isreal,{unit(:).day})) || ...
    ~all(cellfun(@isfinite,{unit(:).day})) || ...
    ~all(cellfun(@(c) (c >= 0),{unit(:).day})) || ...
    ~all(cellfun(@(c) (round(c) == c),{unit(:).day}))
  warning('day field must be a real non-negative integer scalar');
  bool = false;

elseif ~iscellstr({unit(:).epoch}) || ...
    ~all(strcmp({unit(:).epoch}, ...
    regexp({unit(:).epoch},'[a-zA-Z0-9]*','match','once')))
  warning(['epoch field must be a string containing characters ' ...
      '[a-zA-Z0-9]']);
  bool = false;

elseif ~iscellstr({unit(:).environment}) || ...
    ~all(strcmp({unit(:).environment}, ...
    regexp({unit(:).environment},'[a-zA-Z0-9]*','match','once')))
  warning(['environment field must be a string containing characters ' ...
      '[a-zA-Z0-9]']);
  bool = false;

elseif ~all(cellfun(@isnumeric,{unit(:).timerange})) || ...
    ~all(cellfun(@(c) isa(c,'uint32'),{unit(:).timerange})) || ...
    ~all(cellfun(@isvector,{unit(:).timerange})) || ...
    ~all(cellfun(@(c) (size(c,2) == 2),{unit(:).timerange})) || ...
    ~all(cellfun(@(c) (c(2) > c(1)),{unit(:).timerange}))
  warning(['timerange field must be a 2-element row vector of uint32 ' ...
      'timestamps in increasing order']);
  bool = false;

elseif ~all(cellfun(@isnumeric,{unit(:).tetrode})) || ...
    ~all(cellfun(@isscalar,{unit(:).tetrode})) || ...
    ~all(cellfun(@isreal,{unit(:).tetrode})) || ...
    ~all(cellfun(@isfinite,{unit(:).tetrode})) || ...
    ~all(cellfun(@(c) (c > 0),{unit(:).tetrode})) || ...
    ~all(cellfun(@(c) (round(c) == c),{unit(:).tetrode}))
  warning('tetrode field must be a real positive integer scalar');
  bool = false;

elseif ~all(cellfun(@isnumeric,{unit(:).depth})) || ...
    ~all(cellfun(@isscalar,{unit(:).depth})) || ...
    ~all(cellfun(@isreal,{unit(:).depth})) || ...
    ~all(cellfun(@isfinite,{unit(:).depth})) || ...
    ~all(cellfun(@(c) (round(c) == c),{unit(:).depth}))
  warning('depth field must be an integer scalar');
  bool = false;

elseif ~iscellstr({unit(:).hemisphere}) || ...
    ~all(strcmp({unit(:).hemisphere}, ...
    regexp({unit(:).hemisphere},'[a-zA-Z0-9_]*','match','once')))
  warning(['hemisphere field must be a string containing characters ' ...
      '[a-zA-Z0-9_]']);
  bool = false;

elseif ~iscellstr({unit(:).region}) || ...
    any(cellfun(@isempty,{unit(:).region})), ...
  warning(['region field must be a non-empty string']);
  bool = false;

elseif ~all(cellfun(@isnumeric,{unit(:).reference})) || ...
    ~all(cellfun(@isvector,{unit(:).reference})) || ...
    ~all(cellfun(@(c) (size(c,1) == 1),{unit(:).reference})) || ...
    ~all(cellfun(@(c) (size(c,2) == 2),{unit(:).reference})) || ...
    ~all(cellfun(@(c) isreal(c),{unit(:).reference})) || ...
    ~all(cellfun(@(c) (c(1) >= 0),{unit(:).reference})) || ...
    ~all(cellfun(@(c) (c(2) >= 0),{unit(:).reference}))
  warning(['reference field must be a 2-element row vector of real ' ...
      'non-negative integer values']);
  bool = false;

elseif ~all(cellfun(@isnumeric,{unit(:).passbands})) || ...
    ~all(cellfun(@(c) (size(c,1) == NCHANNELS),{unit(:).passbands})) || ...
    ~all(cellfun(@(c) (size(c,2) == 2),{unit(:).passbands})) || ...
    ~all(cellfun(@(c) isreal(c),{unit(:).passbands})) || ...
    ~all(cellfun(@(c) all(c(:) > 0),{unit(:).passbands})) || ...
    ~all(cellfun(@(c) all(c(:,2) > c(:,1)),{unit(:).passbands}))
  warning(sprintf(['passbands field must be a %dx2 array of real ' ...
      'positive values in increasing order'],NCHANNELS));
  bool = false;

elseif ~all(cellfun(@isnumeric,{unit(:).timestamp})) || ...
    ~all(cellfun(@(c) isa(c,'uint32'),{unit(:).timestamp})) || ...
    ~all(cellfun(@isvector,{unit(:).timestamp})) || ...
    ~all(cellfun(@(c) (size(c,2) == 1),{unit(:).timestamp})) || ...
    ~all(cellfun(@(c) isreal(c),{unit(:).timestamp})) || ...
    ~all(cellfun(@(c) all(diff(c) > 0),{unit(:).timestamp}))
  warning(['timestamp field must be a column vector of strictly ' ...
      'monotonically increasing real uint32 timestamps']);
  bool = false;

elseif ~all(cellfun(@isnumeric,{unit(:).Fs})) || ...
    ~all(cellfun(@isscalar,{unit(:).Fs})) || ...
    ~all(cellfun(@(c) isa(c,'double'),{unit(:).Fs})) || ...
    ~all(cellfun(@isreal,{unit(:).Fs})) || ...
    ~all(cellfun(@isfinite,{unit(:).Fs})) || ...
    ~all(cellfun(@(c) (c > 0),{unit(:).Fs}))
  warning('Fs field must be a real positive scalar');
  bool = false;

elseif ~all(cellfun(@isnumeric,{unit(:).samples_before_trigger})) || ...
    ~all(cellfun(@isscalar,{unit(:).samples_before_trigger})) || ...
    ~all(cellfun(@isreal,{unit(:).samples_before_trigger})) || ...
    ~all(cellfun(@isfinite,{unit(:).samples_before_trigger})) || ...
    ~all(cellfun(@(c) round(c)==c,{unit(:).samples_before_trigger})) || ...
    ~all(cellfun(@(c) c > 0,{unit(:).samples_before_trigger}))
  warning('samples_before_trigger field must a positive integer');
  bool = false;

elseif ~all(arrayfun(@(s) size(s.samples,1) > s.samples_before_trigger,unit))
  warning(['samples_before_trigger field must be smaller than the ' ...
      'number of samples per capture']);
  bool = false;

elseif ~all(cellfun(@isnumeric,{unit(:).thresholds})) || ...
    ~all(cellfun(@isvector,{unit(:).thresholds})) || ...
    ~all(cellfun(@(c) numel(c)==NCHANNELS,{unit(:).thresholds})) || ...
    ~all(cellfun(@(c) isreal(c),{unit(:).thresholds})) || ...
    ~all(cellfun(@(c) all(isfinite(c)),{unit(:).thresholds})) || ...
    ~all(cellfun(@(c) all(c > 0),{unit(:).thresholds}))
  warning(['thresholds field must be a %d-element row vector of real ' ...
      'positive values'],NCHANNELS);
  bool = false;

elseif ~all(arrayfun(@(s) all(any(any(s.samples <= ...
  repmat(-s.thresholds(:)', [size(s.samples,1) 1 size(s.samples,3)]),1),2)), ...
  unit))
  % Verify that thresholds are appropriate: in every event, at least one channel
  % must exceed its threshold
  warning('some events do not cross thresold');
  bool = false;

elseif ~all(cellfun(@isnumeric,{unit(:).amplitude_cutoff})) || ...
    ~all(cellfun(@isvector,{unit(:).amplitude_cutoff})) || ...
    ~all(cellfun(@(c) numel(c)==NCHANNELS,{unit(:).amplitude_cutoff})) || ...
    ~all(cellfun(@(c) isreal(c),{unit(:).amplitude_cutoff})) || ...
    ~all(cellfun(@(c) all(c > 0),{unit(:).amplitude_cutoff}))
  warning(['amplitude_cutoff field must be a %d-element row vector of real ' ...
      'positive values'],NCHANNELS);
  bool = false;

elseif ~all(arrayfun(@(s) all(all(all(abs(s.samples) <= repmat( ...
    s.amplitude_cutoff(:)', [size(s.samples,1) 1 size(s.samples,3)]),2), ...
    3),1),unit))
  % Verify that amplitude_cutoff are appropriate: for a given channel, all
  % sample values must be small than the cutoff for that channel
  warning('some threshold-crossing events exceed amplitude cutoff');
  bool = false;

elseif ~all(cellfun(@isnumeric,{unit(:).samples})) || ...
    ~all(cellfun(@(c) ndims(c) == 3,{unit(:).samples})) || ...
    ~all(cellfun(@(c) size(c,2)==NCHANNELS,{unit(:).samples})) || ...
    ~all(cellfun(@(c) isa(c,'int16'),{unit(:).samples})) || ...
    ~all(cellfun(@(c) isreal(c),{unit(:).samples}))
  warning('samples field must be a 3-dimensional array of int16 values');
  bool = false;

elseif arrayfun(@(s) numel(s.timestamp) ~= size(s.samples,3),unit)
  warning(['number of timestamps must match size along third dimension ' ...
      'of samples field']);
  bool = false;

elseif ~all(cellfun(@iscellstr,{unit(:).sources})) || ...
    ~all(cellfun(@(c) all(cellfun(@exist,c) == 2),{unit(:).sources})) || ...
    ~all(cellfun(@(c) all(cellfun(@(cc) isdir(fileparts(cc)),c)), {unit(:).sources}))
  warning(['sources field must be a cell array of strings that specify filenames, ' ...
      'including path']);
  bool = false;

else
  [i1, i2] = ndgrid(1:numel(unit));
  pair_idx = find(i1 ~= i2);
  i1 = i1(pair_idx);
  i2 = i2(pair_idx);
  % Check that no two elements of unit duplicate the same
  % (subject, day, epoch, tetrode, clustnum) 4-tuple
  if any(arrayfun(@(s1,s2) isequal( ...
      {s1.subject, s1.day, s1.epoch, s1.tetrode, s1.clustnum}, ...
      {s2.subject, s2.day, s2.epoch, s2.tetrode, s2.clustnum}), ...
      unit(i1),unit(i2)))
    warning(['unit data structs in the same array have duplicate ' ...
        'information for the same unit']);
    bool = false;
  % Check that no two elements of unit which share the same 
  % (subject, day, tetrode) 3-tuple have discrepant depth or region fields
  elseif any( arrayfun(@(s1,s2) isequal( ...
      {s1.subject, s1.day, s1.tetrode}, ...
      {s2.subject, s2.day, s2.tetrode}),unit(i1),unit(i2)) & ...
      arrayfun(@(s1,s2) ...
      ~isequal(s1.depth,s2.depth) || ~isequal(s1.region,s2.region), ...
      unit(i1),unit(i2)) )
    warning(['unit data structs in the same array have discrepant ' ...
        'recording locations for the same tetrode']);
    bool = false;
  else
    bool = true;
  end

end

