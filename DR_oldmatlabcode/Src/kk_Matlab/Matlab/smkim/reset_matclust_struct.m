function newclust = reset_matclust_struct(oldclust,session)
%RESET_MATCLUST_STRUCT Erase all cluster assignments and reconstruct time filters.
%   NEWCLUST = RESET_MATCLUST_STRUCT(OLDCLUST, SESSION) takes an existing
%   Matclust struct and deletes all clusters and replaces timefilters with
%   those derived from SESSION. clustdata.params from OLDCLUST is copied to
%   NEWCLUST. The only time when you would want to use this function is when
%   Matclust has corrupted the existing Matclust structure and you do not want
%   to recompute clustdata.params.
%
%   The output CLUST is a struct whose fields are structs: clustattrib,
%   clustdata, graphattrib. 
%
%Depends on:
%   IS_SESSION (written by smk)
%   TS2STR (written by smk)
%   FASTBITSET (written by mpk)
%
%Written by smk, 2009 August 25.
%

if (exist('is_session') ~= 2)
  error('MAKE_MATCLUST_STRUCT depends on m-file IS_SESSION (written by smk)');
end
if (exist('ts2str') ~= 2)
  error('MAKE_MATCLUST_STRUCT depends on m-file TS2STR (written by smk)');
end
if (exist('fastbitset') ~= 3)
  error(['MAKE_MATCLUST_STRUCT depends on mex-file FASTBITSET ' ...
      '(written by mpk)']);
end

% Matclust-specific constants. Do not tamper without thinking.
MAX_NUM_CLUST = 100;
MAX_NUM_FILTERS = 32;
TS_PER_SEC = 1e4;

% Sessions will be divided into time filters of at least this duration
TIME_CHUNK = 60*5; % 5-minute intervals

% Check that SESSION is a valid session data struct array
if ~is_session(session)
  error('SESSION does not appear to be a valid sessions data struct array');
end
% Check whether all elements of SESSION have matching subject and day
if (numel(unique({session(:).subject})) > 1)
  error('SESSION argument has elements whose subject fields differ');
end
if (numel(unique([session(:).day])) > 1)
  error('SESSION argument has elements whose day fields differ');
end

% copy clustdata.params and clustdata.paramnames from OLDCLUST
params = oldclust.clustdata.params;
paramnames = oldclust.clustdata.names;

% remove unnecessary params
params = params(:,1:9);
paramnames = paramnames(1:9);

%

% construct time filters:
% all points belong to the 'all' time filter, which is indexed by 1
% note that 'all' is a *superset* of the union of the time filters defined
% below, because it also includes the gaps which are not included in any of the
% time filters
j = 1; % j is index into clustdata.timefilterranges and clustdata.timefilternames
timefilters = ones([size(params,1) 1],'int32');
timefilterranges = zeros(0,2);
timefilternames = cell([MAX_NUM_FILTERS 1]);
timefilters = fastbitset(timefilters,j,logical(1));
timefilternames{j} = 'all';
timefilterranges(j,1) = -1 + min( ...
    params(1,1),double(min(arrayfun(@(s) s.timerange(1),session))));
timefilterranges(j,2) = +1 + max( ...
    params(end,1),double(max(arrayfun(@(s) s.timerange(2),session))));
% start populating timefilterranges from the second row onwards; at this point,
% we need j to equal 1
assert(j == 1)
for i = 1:length(session)
  % subdivide each session into contiguous timeranges that are approximately
  % TIME_CHUNK in duration
  subdivisions = uint32(round(linspace( ...
      double(session(i).timerange(1)),double(session(i).timerange(end)), ...
      1 + max(1, ...
      round(double(diff(session(i).timerange))/TS_PER_SEC/TIME_CHUNK)) )));
      % number of subdivision is obtained by rounding division of total session
      % length by TIME_CHUNK, with a minimum of 1 subdivision
  if (numel(subdivisions) > 2)
    subdivisions = [subdivisions(1:end-1)', subdivisions(2:end)'];
  end
  assert(is_timerange(subdivisions));
  assert(subdivisions(1,1) == session(i).timerange(1));    
  assert(subdivisions(end,2) == session(i).timerange(end));    
  for k = 1:size(subdivisions,1)
    % j is index into clustdata.timefilterranges and clustdata.timefilternames
    j = j + 1; 
    timefilterranges(j,:) = double(subdivisions(k,:));
    timefilternames{j,1} = sprintf('%s(%s-%s)',session(i).epoch, ...
        ts2str(subdivisions(k,1)),ts2str(subdivisions(k,2)));
    % for each time filter that we define, find the threshold-trigger events
    % that fall within that time filter and apply bitmask to the
    % corresponding element of clustdata.timefilters
    timefilters = fastbitset(timefilters,j, ...
        (uint32(params(:,1)) >= subdivisions(k,1)) & ...
        (uint32(params(:,1)) < subdivisions(k,2)));
  end
end
if size(timefilterranges,1) > MAX_NUM_FILTERS
  error('too many time filters are defined');
else  
  timefiltermemmap = zeros([MAX_NUM_FILTERS 1]);
  timefiltermemmap(1:size(timefilterranges,1)) = 1:size(timefilterranges,1);
end
timefiltersOn = zeros([1 MAX_NUM_FILTERS]);
timefiltersOn(1) = 1;
otherfilternames = cell([MAX_NUM_FILTERS 1]);
for i = 1:length(otherfilternames)
  if i > 1
    otherfilternames{i} = num2str(i);
  else
    otherfilternames{1} = '1 All points';
  end
end
otherfiltermemmap = zeros([MAX_NUM_FILTERS 1]);
otherfiltermemmap(1) = 1;
otherfiltersOn = zeros([1 MAX_NUM_FILTERS]);
otherfiltersOn(1) = 1;
datarange = zeros([2 size(params,2)]);
for i = 1:size(params,2)
  datarange(1,i) = min(params(:,i)) - 0.05*range(params(:,i));
  datarange(2,i) = max(params(:,i)) + 0.05*range(params(:,i));
end

customvar = struct('session',session);
newclust.clustdata = struct( ...
    'filledparam'           , {ones([1 size(params,2)])}              , ...
    'params'                , {params}                                , ...
    'origparams'            , {size(params,2)}                        , ...
    'names'                 , {paramnames}                            , ...
    'timefilterranges'      , {timefilterranges}                      , ...
    'timefilters'           , {timefilters}                           , ...
    'timefiltermemmap'      , timefiltermemmap                        , ...
    'timefiltersOn'         , {timefiltersOn}                         , ...
    'otherfilters'          , {ones([size(params,1) 1],'int32')}      , ...
    'otherfiltermemmap'     , otherfiltermemmap                       , ...
    'otherfiltersOn'        , {otherfiltersOn}                        , ...
    'filtermemmap'          , {[timefiltermemmap; otherfiltermemmap]} , ...
    'filteredpoints'        , {true([size(params,1) 1])}              , ...
    'datarange'             , {datarange}                             , ...
    'UnitsPerSec'           , {TS_PER_SEC}                            , ... 
    'timefilternames'       , {timefilternames}                       , ...
    'otherfilternames'      , {otherfilternames}                      , ...
    'customvar'             , {customvar}                             );

newclust.clustattrib = struct( ...
    'clusters'              , {[]}                                    , ...
    'filterindex'           , {[]}                                    , ...
    'takenpolys'            , {[]}                                    , ...
    'eventeditindex'        , {[]}                                    , ...
    'clustersOn'            , {[]}                                    , ...
    'currentfilepath'       , {oldclust.clustattrib.currentfilepath}  , ...
    'currentfilename'       , {oldclust.clustattrib.currentfilename}  , ...
    'currentparamfilename'  , {[]}                                    , ...
    'nodata'                , {0}                                     , ...
    'datafile'              , {oldclust.clustattrib.datafile}         , ...
    'lastaction'            , {''}                                    , ...
    'newchanges'            , {0}                                     , ...
    'states'                , {[]}                                    , ...
    'currstate'             , {1}                                     , ...
    'pointexclude'          , {zeros([size(params,1) 1],'int32')}     , ...
    'pointinclude'          , {zeros([size(params,1) 1],'int32')}     , ...
    'cluster0attrib'        , {struct('color',{[1 1 1]},'show',{1})}  , ...
    'hiddenclusters'        , {zeros([MAX_NUM_CLUST 2])}              , ...
    'currclust'             , {1}                                     , ...
    'dependencies'          , {false([MAX_NUM_CLUST MAX_NUM_CLUST])}  );

viewbox = repmat([zeros([size(params,2) 1]) ones([size(params,2) 1])], ...
    [1 2 size(params,2)]);
newclust.graphattrib = struct( ...
    'polydraw'              , {0}                                     , ...
    'drawsquare'            , {0}                                     , ...
    'magdrawsquare'         , {0}                                     , ...
    'magsquare'             , {[]}                                    , ...
    'handdown'              , {0}                                     , ...
    'handinfo'              , {[]}                                    , ...
    'polyg'                 , {[]}                                    , ...
    'currentpolyhighlight'  , {[]}                                    , ...
    'squarehighlighton'     , {0}                                     , ...
    'pointmoved'            , {0}                                     , ...
    'plothighlightclear'    , {1}                                     , ...
    'polypress'             , {0}                                     , ...
    'relativepolypress'     , {[]}                                    , ...
    'shiftclick'            , {0}                                     , ...
    'viewbox'               , {viewbox}                               , ...
    'oldviewbox'            , {viewbox}                               , ...
    'backgroundcolor'       , {[0 0 0]}                               , ...
    'resolutionfactor'      , {[1 1]}                                 , ...
    'nonhiddenpoints'       , {true([size(params,1) 1])}              , ...
    'blackedOutClusters'    , {[]}                                    );



