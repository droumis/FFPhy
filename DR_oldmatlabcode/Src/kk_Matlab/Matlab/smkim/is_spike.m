function bool = is_spike(spike)
%IS_SPIKE Validate whether the input is a spike struct array
%
%   IS_SPIKE(SPIKE) returns true if SPIKE is a struct array that
%   contains valid spikely-recorded voltage data.
%   
%   See also READ_SPIKE, written by smk.
%
%Written by SMK 2009 June 22.
%

% Number of channels per tetrode
NCHANNELS = 4;

REQUIRED_FIELDS = { ...
    'subject'                 , ...
    'day'                     , ...
    'tetrode'                 , ...
    'depth'                   , ...
    'hemisphere'              , ...
    'region'                  , ...
    'reference'               , ...
    'passbands'               , ...
    'thresholds'              , ...
    'Fs'                      , ...
    'samples_before_trigger'  , ...
    'amplitude_cutoff'        , ...
    'timestamp'               , ...
    'samples'                 , ...
    'sources'                 };

if isempty(spike) && isstruct(spike) && ...
    all(isfield(spike,REQUIRED_FIELDS))
  warning('SPIKE struct is empty');
  bool = true;
  return;

elseif ~isstruct(spike) || ~all(isfield(spike,REQUIRED_FIELDS))
  warning('missing required field(s)');
  bool = false;

elseif ~iscellstr({spike(:).subject}) || ...
    ~all(strcmp({spike(:).subject}, ...
    regexp({spike(:).subject},'[a-zA-Z0-9]*','match','once')))
  warning(['subject field must be a string containing characters ' ...
      '[a-zA-Z0-9]']);
  bool = false;

elseif ~all(cellfun(@isnumeric,{spike(:).day})) || ...
    ~all(cellfun(@isscalar,{spike(:).day})) || ...
    ~all(cellfun(@isreal,{spike(:).day})) || ...
    ~all(cellfun(@isfinite,{spike(:).day})) || ...
    ~all(cellfun(@(c) (c >= 0),{spike(:).day})) || ...
    ~all(cellfun(@(c) (round(c) == c),{spike(:).day}))
  warning('day field must be a real non-negative integer scalar');
  bool = false;

elseif ~all(cellfun(@isnumeric,{spike(:).tetrode})) || ...
    ~all(cellfun(@isscalar,{spike(:).tetrode})) || ...
    ~all(cellfun(@isreal,{spike(:).tetrode})) || ...
    ~all(cellfun(@isfinite,{spike(:).tetrode})) || ...
    ~all(cellfun(@(c) (c > 0),{spike(:).tetrode})) || ...
    ~all(cellfun(@(c) (round(c) == c),{spike(:).tetrode}))
  warning('tetrode field must be a real positive integer scalar');
  bool = false;

elseif ~all(cellfun(@isnumeric,{spike(:).depth})) || ...
    ~all(cellfun(@isscalar,{spike(:).depth})) || ...
    ~all(cellfun(@isreal,{spike(:).depth})) || ...
    ~all(cellfun(@isfinite,{spike(:).depth})) || ...
    ~all(cellfun(@(c) (round(c) == c),{spike(:).depth}))
  warning('depth field must be an integer scalar');
  bool = false;

elseif ~iscellstr({spike(:).hemisphere}) || ...
    ~all(strcmp({spike(:).hemisphere}, ...
    regexp({spike(:).hemisphere},'[a-zA-Z0-9_]*','match','once')))
  warning(['hemisphere field must be a string containing characters ' ...
      '[a-zA-Z0-9_]']);
  bool = false;

elseif ~iscellstr({spike(:).region}) || ...
    ~all(strcmp({spike(:).region}, ...
    regexp({spike(:).region},'[a-zA-Z0-9_]*','match','once')))
  warning(['region field must be a string containing characters ' ...
      '[a-zA-Z0-9_]']);
  bool = false;

elseif ~all(cellfun(@isnumeric,{spike(:).reference})) || ...
    ~all(cellfun(@isvector,{spike(:).reference})) || ...
    ~all(cellfun(@(c) (size(c,1) == 1),{spike(:).reference})) || ...
    ~all(cellfun(@(c) (size(c,2) == 2),{spike(:).reference})) || ...
    ~all(cellfun(@(c) isreal(c),{spike(:).reference})) || ...
    ~all(cellfun(@(c) (c(1) >= 0),{spike(:).reference})) || ...
    ~all(cellfun(@(c) (c(2) >= 0),{spike(:).reference}))
  warning(['reference field must be a 2-element row vector of real ' ...
      'non-negative integer values']);
  bool = false;

elseif ~all(cellfun(@isnumeric,{spike(:).passbands})) || ...
    ~all(cellfun(@(c) (size(c,1) == NCHANNELS),{spike(:).passbands})) || ...
    ~all(cellfun(@(c) (size(c,2) == 2),{spike(:).passbands})) || ...
    ~all(cellfun(@(c) isreal(c),{spike(:).passbands})) || ...
    ~all(cellfun(@(c) all(c(:) > 0),{spike(:).passbands})) || ...
    ~all(cellfun(@(c) all(c(:,2) > c(:,1)),{spike(:).passbands}))
  warning(sprintf(['passbands field must be a %dx2 array of real ' ...
      'positive values in increasing order'],NCHANNELS));
  bool = false;

elseif ~all(cellfun(@isnumeric,{spike(:).timestamp})) || ...
    ~all(cellfun(@(c) isa(c,'uint32'),{spike(:).timestamp})) || ...
    ~all(cellfun(@isvector,{spike(:).timestamp})) || ...
    ~all(cellfun(@(c) (size(c,2) == 1),{spike(:).timestamp})) || ...
    ~all(cellfun(@(c) isreal(c),{spike(:).timestamp})) || ...
    ~all(cellfun(@(c) all(diff(c) > 0),{spike(:).timestamp}))
  warning(['timestamp field must be a column vector of strictly ' ...
      'monotonically increasing real uint32 timestamps']);
  bool = false;

elseif ~all(cellfun(@isnumeric,{spike(:).Fs})) || ...
    ~all(cellfun(@isscalar,{spike(:).Fs})) || ...
    ~all(cellfun(@(c) isa(c,'double'),{spike(:).Fs})) || ...
    ~all(cellfun(@isreal,{spike(:).Fs})) || ...
    ~all(cellfun(@isfinite,{spike(:).Fs})) || ...
    ~all(cellfun(@(c) (c > 0),{spike(:).Fs}))
  warning('Fs field must be a real positive scalar');
  bool = false;

elseif ~all(cellfun(@isnumeric,{spike(:).samples_before_trigger})) || ...
    ~all(cellfun(@isscalar,{spike(:).samples_before_trigger})) || ...
    ~all(cellfun(@isreal,{spike(:).samples_before_trigger})) || ...
    ~all(cellfun(@isfinite,{spike(:).samples_before_trigger})) || ...
    ~all(cellfun(@(c) round(c)==c,{spike(:).samples_before_trigger})) || ...
    ~all(cellfun(@(c) c > 0,{spike(:).samples_before_trigger}))
  warning('samples_before_trigger field must a positive integer');
  bool = false;

elseif ~all(arrayfun(@(s) size(s.samples,1) > s.samples_before_trigger,spike))
  warning(['samples_before_trigger field must be smaller than the ' ...
      'number of samples per capture']);
  bool = false;

elseif ~all(cellfun(@isnumeric,{spike(:).thresholds})) || ...
    ~all(cellfun(@isvector,{spike(:).thresholds})) || ...
    ~all(cellfun(@(c) numel(c)==NCHANNELS,{spike(:).thresholds})) || ...
    ~all(cellfun(@(c) isreal(c),{spike(:).thresholds})) || ...
    ~all(cellfun(@(c) all(isfinite(c)),{spike(:).thresholds})) || ...
    ~all(cellfun(@(c) all(c > 0),{spike(:).thresholds}))
  warning(['thresholds field must be a %d-element row vector of real ' ...
      'positive values'],NCHANNELS);
  bool = false;

elseif ~all(arrayfun(@(s) all(any(any(s.samples <= ...
  repmat(-s.thresholds(:)', [size(s.samples,1) 1 size(s.samples,3)]),1),2)), ...
  spike))
  % Verify that thresholds are appropriate: in every event, at least one channel
  % must exceed its threshold
  warning('some events do not cross thresold');
  bool = false;

elseif ~all(cellfun(@isnumeric,{spike(:).amplitude_cutoff})) || ...
    ~all(cellfun(@isvector,{spike(:).amplitude_cutoff})) || ...
    ~all(cellfun(@(c) numel(c)==NCHANNELS,{spike(:).amplitude_cutoff})) || ...
    ~all(cellfun(@(c) isreal(c),{spike(:).amplitude_cutoff})) || ...
    ~all(cellfun(@(c) all(c > 0),{spike(:).amplitude_cutoff}))
  warning(['amplitude_cutoff field must be a %d-element row vector of real ' ...
      'positive values'],NCHANNELS);
  bool = false;

elseif ~all(arrayfun(@(s) all(all(all(abs(s.samples) <= repmat( ...
    s.amplitude_cutoff(:)', [size(s.samples,1) 1 size(s.samples,3)]),2), ...
    3),1),spike))
  % Verify that amplitude_cutoff are appropriate: for a given channel, all
  % sample values must be small than the cutoff for that channel
  warning('some threshold-crossing events exceed amplitude cutoff');
  bool = false;

elseif ~all(cellfun(@isnumeric,{spike(:).samples})) || ...
    ~all(cellfun(@(c) ndims(c) == 3,{spike(:).samples})) || ...
    ~all(cellfun(@(c) size(c,2)==NCHANNELS,{spike(:).samples})) || ...
    ~all(cellfun(@(c) isa(c,'int16'),{spike(:).samples})) || ...
    ~all(cellfun(@(c) isreal(c),{spike(:).samples}))
  warning('samples field must be a 3-dimensional array of int16 values');
  bool = false;

elseif arrayfun(@(s) numel(s.timestamp) ~= size(s.samples,3),spike)
  warning(['number of timestamps must match size along third dimension ' ...
      'of samples field']);
  bool = false;

elseif ~all(cellfun(@iscellstr,{spike(:).sources})) || ...
    ~all(cellfun(@(c) all(cellfun(@exist,c) == 2),{spike(:).sources})) || ...
    ~all(cellfun(@(c) all(cellfun(@(cc) isdir(fileparts(cc)),c)), {spike(:).sources}))
  warning(['sources field must be a cell array of strings that specify filenames, ' ...
      'including path']);
  bool = false;

else
  [i1, i2] = ndgrid(1:numel(spike));
  pair_idx = find(i1 ~= i2);
  i1 = i1(pair_idx);
  i2 = i2(pair_idx);
  % Check that no two elements of spike duplicate the same
  % (subject, day, epoch, tetrode) 4-tuple
  if any(arrayfun(@(s1,s2) isequal( ...
      {s1.subject, s1.day, s1.epoch, s1.tetrode}, ...
      {s2.subject, s2.day, s2.epoch, s2.tetrode}), ...
      spike(i1),spike(i2)))
    warning(['spike data structs in the same array have duplicate ' ...
        'information for the same tetrode']);
    bool = false;
  % Check that no two elements of spike which share the same 
  % (subject, day, tetrode) 3-tuple have discrepant depth or region fields
  elseif any( arrayfun(@(s1,s2) isequal( ...
      {s1.subject, s1.day, s1.tetrode}, ...
      {s2.subject, s2.day, s2.tetrode}),spike(i1),spike(i2)) & ...
      arrayfun(@(s1,s2) ...
      ~isequal(s1.depth,s2.depth) || ~isequal(s1.region,s2.region), ...
      spike(i1),spike(i2)) )
    warning(['spike data structs in the same array have discrepant ' ...
        'recording locations for the same tetrode']);
    bool = false;
  else
    bool = true;
  end

end

