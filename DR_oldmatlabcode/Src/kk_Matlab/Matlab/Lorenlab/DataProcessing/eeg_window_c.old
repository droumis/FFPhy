/*
 * =============================================================
 *
 *  loadeeg.c
 *
 *  Caleb Kemere 2007-02-28
 *
 *  [data, timestamps]
 *    = eeg_window_c(filename, times, window_length);
 *
 *  [data, timestamps, samplingrate]
 *    = eeg_window_c(filename, times, window_length);
 *
 * =============================================================
 */

#include <stdio.h>
#include <stdint.h>
#include <sys/stat.h>
#include <math.h>
#include <string.h>
#include "mex.h"
#include "matrix.h"

#define MAX_FILENAME 200
#define HEADER_STRLEN 50
#define ERROR_STRLEN 500
#define MAX_NSAMPLES 5000

typedef uint32_t u32;


FILE *eegfile;
double actualSamplingRate = 0;

typedef struct _eegRecord {
  u32 timestamp;
  int samplingRate;
  int numSamples;
  int16_t data[MAX_NSAMPLES]
  double firstTimestamp;
  double lastTimestamp;
} eegRecord;

eegRecord nextRecord;

int getNextRecord (int calcOffset);

/* The gateway routine */
void mexFunction(int nlhs, mxArray *plhs[],
                 int nrhs, const mxArray *prhs[])
{
  char filename[MAX_FILENAME];
  int filenameLength=0;

  int nWindows;
  int window_length; /* length of window in timestamps */
  int windowLen; /* length of window in SAMPLES */

  double *dEEGData, *dStartTimestamp, *dStartActual;

  int16_t *data;

  char *header;
  char headerString[500];
  char tmpString[HEADER_STRLEN];

  size_t recordPtr;

  eegRecord nextRecord;

  /* for filename prediction */
  struct stat filestat;
  int recordLength;
  long int recordsPerFile;

  long int i;
  int temp;
  char errorString[ERROR_STRLEN];
  
  /* PROCESS INPUT ARGUMENTS */
  /* ----------------------------------------------------------*/
  /*  Check for proper number of arguments. */
  if (nrhs < 3) 
    mexErrMsgTxt("Missing arguments: filename, times, window-length required.");

  /*  Assume most other error checking taken care of by matlab
   *  wrapper, e.g., filename length, times is Nx1, verbose-flag
   *  provided.
   */
  
  /* Check to make sure file exists and is openable. */
  mxGetString(prhs[0], filename, MAX_FILENAME-1);
  eegfile = fopen(filename, "r");
  if (!eegfile) {
    sprintf(errorString,"Could not open file: %s; Return value %d\n", filename, (int) eegfile);
    mexErrMsgTxt(errorString);
  }

  /* ----------------------------------------------------------*/

  /* Get file size for time prediction. */
  stat(filename,&filestat);

  /* Read in header.... */
  fgets(tmpString,HEADER_STRLEN,eegfile);
  if (strcmp("%%BEGINHEADER\n",tmpString) != 0)
    mexErrMsgTxt("File has unknown header.");
  fgets(tmpString,HEADER_STRLEN,eegfile);
  headerString[0] = (char) 0;
  while (strcmp("%%ENDHEADER\n",tmpString) != 0) {
    strcat(headerString,tmpString);
    strcat(headerString,"\n");
    fgets(tmpString,HEADER_STRLEN,eegfile);
  }

  /* ----------------------------------------------------------*/
  /* PROCESS OUTPUT ARGUMENTS */

  recordPtr = ftell(eegfile);

  window_length = mxGetScalar(prhs[2]); /* length of window in timestamps */
  nWindows = mxGetM(prhs[1]); /* length of times vector */

  getNextRecord();

  windowLen = round( window_length * ((double) actualSamplingRate / 10000.0) );

  data = mxCalloc(windowLen, sizeof(int16_t));

  /* 
     Now we can initialize our outputs... 
   */
  plhs[0] = mxCreateDoubleMatrix(nWindows,windowLen,mxREAL); /* output 1: eeg windows */
  plhs[1] = mxCreateDoubleMatrix(nWindows,1,mxREAL); /* output 2: window start timestamps */
  plhs[2] = mxCreateDoubleScalar(actualSamplingRate); /* output 3: sampling rate */

  recordLength = sizeof(u32) + sizeof(int) + sizeof(double) + \
                 sizeof(short)*nextRecord.numSamples;
  recordsPerFile = (filestat.st_size - recordPtr)/recordLength;
  if ( fmod(((double) filestat.st_size - recordPtr), (double)recordLength) != 0)
    mexWarnMsgTxt("File length does not match predicted.\n");

  /*
     Ok, so we need to loop through the records and the window
     start times. Keep a look out for missing data at beginnings
     and ends, and for overlapping data - probably easiest to
     ftell and fseek for this.
     */

  dEEGData = mxGetData(plhs[0]);

  dStartTimestamp = mxGetData(prhs[1]);
  dStartActual = mxGetData(plhs[1]);

  for (i = 0; i <= nWindows; i++) {
  }
  
  fclose(eegfile);
  mxFree(data);
}

int getNextRecord (int calcOffset) {
  static u32 lastTimestamps[2];

  u32 timestamp; 
  int numSamples;
  double samplingRate;
  double nTimestamps;

  double offset;

  static double recordTimestamps = 0;
  int i;

  int d1, d2;

  int largeSkipFlag;

  size_t err;
  fpos_t filePos;
    
  err = fread(&timestamp, sizeof(u32), 1, eegfile); /* Read in first data record. */
  if (!err) mxErrMsgTxt("fread error");
  err = fread(&numSamples, sizeof(int), 1, eegfile);
  if (!err) mxErrMsgTxt("fread error");
  err = fread(&samplingRate, sizeof(double), 1, eegfile); 
  if (!err) mxErrMsgTxt("fread error");

  /* ===================================================== *
   *  If it is undefined, find global actualSamplingRate
   */
  if (actualSamplingRate == 0) {
    actualSamplingRate = 30000.0;
    i = 0;
    while (floor(actualSamplingRate/(i+1)) >= samplingRate)
      i = i + 1;
    actualSamplingRate = actualSamplingRate / i;
  }
  /* ===================================================== */
  recordTimestamps = (double) numSamples * 10000.0 / actualSamplingRate; 

  if (firstCall == 0) {
    if (nextRecord.numSamples != numSamples) {
      printf("Old: %X, new: %X\n", nextRecord.numSamples, numSamples);
      mxErrMsgTxt("numSamples changed!!");
    }
    if (nextRecord.samplingRate != samplingRate)
      mxErrMsgTxt("Sampling rate changed!!");

    largeSkipFlag = 0;
    if (((timestamp - nextRecord.timestamp)- floor(recordTimestamps)) > 1)
      largeSkipFlag = 1;
  }

  lastRecord.samplingRate = samplingRate;
  lastRecord.numSamples = numSamples;

  if ((calcOffset == 1) || (largeSkipFlag == 1)) {
    /* get next two records */
    fgetpos(eegfile, &filePos);
    fseek(eegfile, numSamples*sizeof(int16_t), SEEK_CUR);
    err = fread(&lastTimestamps[1], sizeof(u32), 1, eegfile);
    if (!err) mxErrMsgTxt("fread error");
    fseek(eegfile, sizeof(int) + sizeof(double) + numSamples*sizeof(int16_t), SEEK_CUR);
    err = fread(&lastTimestamps[0], sizeof(u32), 1, eegfile);
    if (!err) mxErrMsgTxt("fread error");
    fsetpos(eegfile, &filePos);

    offset = 0.0;
    d1 = round((lastTimestamps[0] - 2*recordTimestamps) - (timestamp + offset));
    d2 = round((lastTimestamps[1] - recordTimestamps) - (timestamp + offset));
    fprintf(stdout,"%d %d |  %d %f %f %f\n", d1, d2, timestamp,
        lastTimestamps[0] + recordTimestamps, lastTimestamps[1] + 2*recordTimestamps, recordTimestamps);
    if ((d1 != 0) || (d2 != 0)) {
      offset = 1.0/3;
    d1 = round((lastTimestamps[0] - 2*recordTimestamps) - (timestamp + offset));
    d2 = round((lastTimestamps[1] - recordTimestamps) - (timestamp + offset));
    fprintf(stdout,"%d %d |  %d %f %f %f\n", d1, d2, timestamp,
        lastTimestamps[0] + recordTimestamps, lastTimestamps[1] + 2*recordTimestamps, recordTimestamps);
      if ((d1 != 0) || (d2 != 0)) {
        offset = -1.0/3;
    d1 = round((lastTimestamps[0] - 2*recordTimestamps) - (timestamp + offset));
    d2 = round((lastTimestamps[1] - recordTimestamps) - (timestamp + offset));
    fprintf(stdout,"%d %d |  %d %f %f %f\n", d1, d2, timestamp,
        lastTimestamps[0] + recordTimestamps, lastTimestamps[1] + 2*recordTimestamps, recordTimestamps);
      }
    }
  }
  /* Based on previous and current timestamps, figure out
   * fractional part of timestamp... */

  lastRecord.firstTimestamp = (double) timestamp + offset; 
  lastRecord.lastTimestamp = lastRecord.firstTimestamp + (numSamples - 1) * 10000.0 / actualSamplingRate;

  lastRecord.timestamp = timestamp;

  firstCall = 0;

  fprintf(stdout,"%d %f timestamp %d %f %f\n",lastRecord.numSamples,
      actualSamplingRate, timestamp, lastRecord.firstTimestamp,
      lastRecord.lastTimestamp);

  return lastRecord;
}
