/* extract_frames.cpp
This program takes outputs from nspike_extract, and saves mpeg movie frames 
within the specified range of timestamps as png files. Usage (--help):

    extract_frames -p MPEGFILE -t TIMESTAMPFILE [-f OFFSETFILE | -f64 OFFSETFILE] 
      -tstart TSTART -tend TEND -o OUTPUTPATTERN

  -p    MPEGFILE is an mpeg file generated by nspike_extract
  -t    TIMESTAMPFILE is a timestamps file generated by nspike_extract
  -f*   OFFSETFILE is either 32-bit (-f) or 64-bit (-f64) offsets file
        generated by nspike_extract
  -t*   TSTART and TEND are floating-point times in seconds
  -o    OUTPUTPATTERN is a sprintf-style string for naming output png files

last edited by SMK, 4 March 2008
*/

#define _FILE_OFFSET_BITS 64 //define for 64 bit offsets
#define fopen fopen64

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <limits.h>
#include <sys/types.h>
#include <inttypes.h> // this is needed by libmpeg2 for uint8_t

extern "C" {
    #include <mpeg2dec/mpeg2.h>
    #include <mpeg2dec/mpeg2convert.h>
}
/* libmpeg2 defines:
    mpeg2dec_t
    mpeg2_info_t
    mpeg2_convert_t
*/

#include <png.h>
/* libpng defines:
    png_structp
    png_infop
    png_byte
    png_bytep
*/

// I don't like using typedef, but this is for consistent style with other NSpike code
typedef unsigned int u32;

/* global variables */
const int SUCCESS = 0;
const int FAILURE = 1;
const double TIMESTAMPS_PER_SECOND = 1.0e4; // NSpike system uses 0.1ms timestamps
int offset_flag = 0; // offset_flag==1 for u32 offsets; offset_flag==2 for ULL offsets
FILE *mpeg_fp;
FILE *timestamp_fp;
FILE *offset_fp;
u32 *timestamps;
u32 *offsets_u32;
unsigned long long int *offsets_ULL;
size_t num_offsets;
size_t num_timestamps;
mpeg2dec_t *mpeg_decoder;
/* note that mpeg_info is declared as const, so that it consistently refers to 
a fixed address in mpeg_decoder! thus, changes in the state of mpeg_decoder can be 
accessed via mpeg_info */
const mpeg2_info_t *mpeg_info;

/* function prototypes */
int read_timestamps(void);
int dump_frame(long int i, char *png_fn);

/* read offsets and timestamps from files into corresponding global variables */
int read_timestamps(void) {
    const size_t JUNK_SIZE = 1000;
    char junk[JUNK_SIZE];
    long int eoh;
    size_t read_count;

    /* read timestamps from the timestamps file */
    do { // read until just past the end-of-header sentinel ("%%ENDHEADER\n")
        fgets(junk, JUNK_SIZE, timestamp_fp);
    } while (strncmp(junk, "%%ENDHEADER", 10) != 0);
    eoh = ftell(timestamp_fp);
    fseek(timestamp_fp, 0, SEEK_END);
    num_timestamps = (size_t) (ftell(timestamp_fp) - eoh) / sizeof(u32);
    timestamps = (u32 *) malloc(num_timestamps * sizeof(u32));
    if (timestamps == NULL) {
        fprintf(stderr, "[read_timestamps] Memory could not be allocated for timestamps\n");
        return FAILURE;
    }
    fseek(timestamp_fp, eoh, SEEK_SET);
    read_count = fread(timestamps, sizeof(u32), num_timestamps, timestamp_fp);
    fclose(timestamp_fp);
    if (read_count != num_timestamps) {
        fprintf(stderr, "[read_timestamps] Error reading offsets\n");
        return FAILURE;
    }
    /* read frame positions in the mpeg file from the offsets file */
    do { // read until just past the end-of-header sentinel ("%%ENDHEADER\n")
        fgets(junk, JUNK_SIZE, offset_fp);
    } while (strncmp(junk, "%%ENDHEADER", 10) != 0);
    eoh = ftell(offset_fp);
    switch (offset_flag) { 
    case 1: // -f (u32 offset)
        fseek(offset_fp, 0, SEEK_END);
        num_offsets = (size_t) (ftell(offset_fp) - eoh) / sizeof(u32);
        offsets_u32 = (u32 *) malloc(num_offsets * sizeof(u32));
        if (offsets_u32 == NULL) {
            fprintf(stderr, "[read_timestamps] Memory could not be allocated for offsets\n");
            return FAILURE;
        }
        fseek(offset_fp, eoh, SEEK_SET);
        read_count = fread(offsets_u32, sizeof(u32), num_offsets, offset_fp);
        fclose(offset_fp);
        if (read_count != num_offsets) {
            fprintf(stderr, "[read_timestamps] Error reading offsets\n");
            return FAILURE;
        }
        break;
    case 2: // -f64 (unsigned long long int offset)
        fseek(offset_fp, 0, SEEK_END);
        num_offsets = (size_t) (ftell(offset_fp) - eoh) / sizeof(unsigned long long int);
        offsets_ULL = (unsigned long long int *) malloc(num_offsets * sizeof(unsigned long long int));
        if (offsets_ULL == NULL) {
            fprintf(stderr, "[read_timestamps] Memory could not be allocated for offsets\n");
            return FAILURE;
        }
        fseek(offset_fp, eoh, SEEK_SET);
        read_count = fread(offsets_ULL, sizeof(unsigned long long int), num_offsets, offset_fp);
        fclose(offset_fp);
        if (read_count != num_offsets) {
            fprintf(stderr, "[read_timestamps] Error reading offsets\n");
            return FAILURE;
        }
        break;
    default:
        fclose(offset_fp);
		fprintf(stderr, "[read_timestamps] Format of offsets not correctly specified\n");
        return FAILURE;
    }
    /* check that timestamps and offsets line up */
    if (num_timestamps != num_offsets) {
        fprintf(stderr, "[read_timestamps] Number of timestamps (%d) does not match"
        "number of offsets (%d)\n", num_timestamps, num_offsets);
        return FAILURE;
    }

    return SUCCESS;
}

/* dump the mpeg video frame corresponding to the ith timestamp; if no png_fn 
argument is given, the image data are not written to file */
int dump_frame(long int i, char *png_fn = NULL) {
    const size_t MPEG_BUFFER_SIZE = 16384;
    // these constants must agree for correct conversion from MPEG to PNG!
    const mpeg2_convert_t *MPEG_CONVERSION_SYMBOL = mpeg2convert_rgb24;
    const png_byte COLOR_TYPE = PNG_COLOR_TYPE_RGB;
    const png_byte BIT_DEPTH = 8;

    int j;
    uint8_t buffer[MPEG_BUFFER_SIZE];
    mpeg2_state_t state;
    size_t size;
    int complete_frame_flag;
    int width, height;
    // dynamically-allocated array of pixel RGB values
    png_byte *image_data = NULL; 
    // dynamically-allocated array of pointers to the first pixel in each row of image_data
    png_byte **row_pointers = NULL; 
    FILE *png_fp;
    png_structp png_ptr;
    png_infop png_info;

    /* seek to the desired frame */
    switch (offset_flag) { 
    case 1: // (u32 offset)
        /* fseek takes an offset argument of type (long int) */
        fseek(mpeg_fp, (long int) offsets_u32[i], SEEK_SET);
        break;
    case 2: // (ULL offset)
        /* fseeko takes an offset argument of type (off_t) */
        fseeko(mpeg_fp, (off_t) offsets_ULL[i], SEEK_SET);
        break;
    default:
		fprintf(stderr, "[dump_frame] Format of offsets not correctly specified\n");
        return FAILURE;
    }
    
    // reset mpeg decoder, with the full_reset argument set to 0
	mpeg2_reset(mpeg_decoder, 0);
    complete_frame_flag = 0;
    size = (size_t)-1;
    do {
	    state = mpeg2_parse(mpeg_decoder);
    	switch (state) {
	    case STATE_BUFFER:
	        size = fread(buffer, 1, MPEG_BUFFER_SIZE, mpeg_fp);
    	    mpeg2_buffer(mpeg_decoder, buffer, buffer + size);
    	    break;
	    case STATE_SEQUENCE:
	        mpeg2_convert(mpeg_decoder, MPEG_CONVERSION_SYMBOL, NULL);
    	    break;
	    case STATE_SLICE:
	        mpeg2_convert(mpeg_decoder, MPEG_CONVERSION_SYMBOL, NULL);
            break;
	    case STATE_PICTURE:
	        mpeg2_convert(mpeg_decoder, MPEG_CONVERSION_SYMBOL, NULL);
            break;
    	default:
	        break;
	    }
        // check whether the decoder has read enough to populate mpeg_info
        if ( (mpeg_info->display_fbuf) && (mpeg_info->sequence)) {
            complete_frame_flag = 1;
        }
    } while ( size && !complete_frame_flag );

    /* mpeg_info->display_fbuf->buf is an array of width*height triples of 
    uint8_t (0 to 255) R,G,B values, ordered first by columns (within row) 
    and then by rows. image_data is an array containing the same values, 
    cast as (png_byte). row_pointers is an array of pointers to the start
    of each row in image_data */
    if ( (mpeg_info->display_fbuf) && (mpeg_info->sequence) ) {
        width = mpeg_info->sequence->width;
        height = mpeg_info->sequence->height;
        image_data = new png_byte[3*width*height];
        for (j = 0; j<3*width*height; j++) {
            // convert from uint8_t to png_byte
            image_data[j] = (png_byte) *(mpeg_info->display_fbuf->buf[0] + j);
        }
        row_pointers = new png_byte*[height];
        for (j = 0; j<height; j++) {
            row_pointers[j] = (png_byte*) &(image_data[j*3*width]);
        }
    } else {
		fprintf(stderr, "[dump_frame] Could not find mpeg frame at %dth offset\n", i);
        return FAILURE;
    }

    // if a png file name is supplied...
    if (png_fn != NULL) {
        /* create png file */
        png_fp = fopen(png_fn, "wb");
        if (png_fp == NULL) {
            fprintf(stderr, "[dump_frame] File %s could not be opened for writing\n", png_fn);
            return FAILURE;
        }
        /* initialize png struct */
        png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
        if (png_ptr == NULL) {
            fprintf(stderr, "[dump_frame] png_create_write_struct failed\n");
            return FAILURE;
        }
        png_info = png_create_info_struct(png_ptr);
        if (png_info == NULL) {
            fprintf(stderr, "[dump_frame] png_create_info_struct failed\n");
            return FAILURE;
        }
        if (setjmp(png_jmpbuf(png_ptr))) {
            fprintf(stderr, "[dump_frame] Error during png init_io\n");
            return FAILURE;
        }
        png_init_io(png_ptr, png_fp);
        /* write png header */
        if (setjmp(png_jmpbuf(png_ptr))) {
            fprintf(stderr, "[dump_frame] Error during writing png header\n");
            return FAILURE;
        }
        png_set_IHDR(png_ptr, png_info, width, height, BIT_DEPTH, COLOR_TYPE, 
            PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);
        png_write_info(png_ptr, png_info);
        /* write png IDAT bytes */
        if (setjmp(png_jmpbuf(png_ptr))) {
            fprintf(stderr, "[dump_frame] Error during writing png image data\n");
            return FAILURE;
        }
        png_write_image(png_ptr, row_pointers);
        /* end write */
        if (setjmp(png_jmpbuf(png_ptr))) {
            fprintf(stderr, "[dump_frame] Error during end of png write\n");
            return FAILURE;
        }
        png_write_end(png_ptr, NULL);
        /* cleanup */
        delete [] row_pointers;
        row_pointers = NULL;
        delete [] image_data;
        image_data = NULL;   
        fclose(png_fp);
    }

    return SUCCESS;
}

/* alert the user to proper usage */
void usage(void) {
    fprintf(stderr, "Save mpeg movie frames within specified range of timestamps as png files. Usage:\n");
    fprintf(stderr, "\n");
    fprintf(stderr, "    extract_frames -p MPEGFILE -t TIMESTAMPFILE [-f OFFSETFILE | -f64 OFFSETFILE] \n"); 
    fprintf(stderr, "      -tstart TSTART -tend TEND -o OUTPUTPATTERN\n");
    fprintf(stderr, "\n");
    fprintf(stderr, "  -p    MPEGFILE is an mpeg file generated by nspike_extract\n");
    fprintf(stderr, "  -t    TIMESTAMPFILE is a timestamps file generated by nspike_extract\n");
    fprintf(stderr, "  -f*   OFFSETFILE is either 32-bit (-f) or 64-bit (-f64) offsets file\n");
    fprintf(stderr, "        generated by nspike_extract\n");
    fprintf(stderr, "  -t*   TSTART and TEND are floating-point times in seconds\n");
    fprintf(stderr, "  -o    OUTPUTPATTERN is a sprintf-style string for naming output png files\n");
}

int main(int argc, char **argv) {
    char word[255];
    // it is very important that all char arrays be initialized as empty strings!!!
    char mpeg_fn[255] = "";
    char timestamp_fn[255] = "";
    char offset_fn[255] = "";
    char png_pattern[255] = "";
    // we assume that all times are strictly positive!!! this code will fail otherwise
    double t_start = 0.0; 
    double t_end = 0.0;
    long int i_start;
    long int i_end;
    long int i;
    int numchar;
    long png_num;
    char png_fn[255] = "";

    /* parse command-line flags */
    while (argc--) {
        strcpy(word, *argv++);
        if (strcmp(word, "--help") == 0) {
            usage();
            exit(1);
	    } else if (strcmp(word, "-p") == 0) {
            // read the next word 
            argc--; strcpy(mpeg_fn, *argv++);
        } else if (strcmp(word, "-t") == 0) {
            // read the next word
            argc--; strcpy(timestamp_fn, *argv++);
        } else if (strcmp(word, "-f") == 0) {
            if (offset_flag == 0) {
                // read the next word
                argc--; strcpy(offset_fn, *argv++);
                offset_flag = 1;
            } else {
                usage();
                exit(1);
            }
        } else if (strcmp(word, "-f64") == 0) {
            if (offset_flag == 0) {
                // read the next word
                argc--; strcpy(offset_fn, *argv++);
                offset_flag = 2;
            } else {
                usage();
                exit(1);
            }
        } else if (strcmp(word, "-tstart") == 0) {
            // read the next word
            argc--; t_start = atof(*argv++);
        } else if (strcmp(word, "-tend") == 0) {
            // read the next word
            argc--; t_end = atof(*argv++);
        } else if (strcmp(word, "-o") == 0) {
            // read the next word
            argc--; strcpy(png_pattern, *argv++);
        } else if (strncmp(word, "-", 1) == 0) {
            fprintf(stderr, "extract_frames: unrecognized option %s\n", word);
            fprintf(stderr, "use extract_frames --help for usage information\n");
            exit(1);
        }
    }

    /* confirm that the user has supplied all arguments */
    if ( (mpeg_fn[0] == '\0') || (timestamp_fn[0] == '\0') || (offset_fn[0] == '\0') 
        || (png_pattern[0] == '\0') || (t_start == 0) || (t_end == 0)) {
        fprintf(stderr, "extract_frames: missing or wrongly-supplied arguments\n");
        fprintf(stderr, "use extract_frames --help for usage information\n");
        exit(1);
    } else if ( (t_start >= t_end) || (t_start <= 0) || (t_end <= 0) ) {
        fprintf(stderr, "tstart and tend must be non-zero numbers, and tstart must be less than tend\n");
        exit(1);
    } 

    /* open file handles */
    mpeg_fp = fopen(mpeg_fn, "r");
    if (mpeg_fp == NULL) {
        fprintf(stderr, "File %s could not be opened for reading\n", mpeg_fn);
        exit(1);
    }
    timestamp_fp = fopen(timestamp_fn, "r");
    if (timestamp_fp == NULL) {
        fprintf(stderr, "File %s could not be opened for reading\n", timestamp_fn);
        exit(1);
    }
    offset_fp = fopen(offset_fn, "r");
    if (offset_fp == NULL) {
        fprintf(stderr, "File %s could not be opened for reading\n", offset_fn);
        exit(1);
    }

    if (read_timestamps() == SUCCESS) {
        /* identify the range of frames to extract */
        for (i = 0; i < num_timestamps; i++) {
            if (double(timestamps[i])/TIMESTAMPS_PER_SECOND >= t_start) {
                i_start = i;
                break;
            } else if (i == num_timestamps-1) {
                fprintf(stderr, "could not find mpeg frame with timestamp later than tstart (%f seconds)\n", t_start);
                exit(1);
            }
        }
        for (i = num_timestamps-1; i >= 0; i--) {
            if (double(timestamps[i])/TIMESTAMPS_PER_SECOND <= t_end) {
                i_end = i;
                break;
            } else if (i == 0) {
                fprintf(stderr, "could not find mpeg frame with timestamp earlier than tend (%f seconds)\n", t_end);
                exit(1);
            }
        }
        /* initialize mpeg decoder */
        mpeg_decoder = mpeg2_init();
        if (mpeg_decoder == NULL) {
            fprintf(stderr, "Could not allocate an mpeg decoder object.\n");
        }
        mpeg_info = mpeg2_info(mpeg_decoder);
        if (mpeg_info == NULL) {
            fprintf(stderr, "Could not read info from mpeg decoder object.\n");
        }

        /* read the 0th frame of the mpeg; this initializes the mpeg decoder */
        dump_frame(0);

        /* loop through range of desired frames and dump each to png*/
        png_num = 1;

        for (i = i_start; i <= i_end; i++) {
            numchar = sprintf(png_fn, png_pattern, png_num);
            if (numchar <= 0) {
                fprintf(stderr, "Error constructing png file name\n");
                exit(1);
            } 
            if (dump_frame(i, png_fn) == FAILURE) {
                fprintf(stderr, "Error dumping mpeg frame to png\n");
                exit(1);
            }
            png_num++;
        }
        // close mpeg decoder
        mpeg2_close(mpeg_decoder);
    } else {
        fprintf(stderr, "Error reading timestamps\n");
        exit(1);
    }
    exit(0);
}


