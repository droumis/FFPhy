function linearized_passes = find_linearized_passes(linearized,params)
%FIND_LINEARIZED_PASSES Parse individual passes between the two ends of linear track
%
%   PASSES = FIND_LINEARIZED_PASSES(LINEARIZED_POSITION,PARAMS) takes a
%   linearized position data struct and returns a struct in which each element
%   corresponds to a complete individual pass on the linear track. Passes on
%   which the rat fails to run from one end of the track to the other are
%   excluded.
%
%   PARAMS is a struct with fields:
%     'track_interval': a pass is defined as a continuous time interval during
%         which the rat's linearized position falls within this position
%         interval. Expressed in the same units/reference frame as the
%         'position' field of LINEARIZED_POSITION.
%     'discretization_timestep': uint32 timestamp units, resampling resolution
%     'minimum_speed': minimum speed for identifying times when rat is running
%         forward, expressed in units of 'speed' field of LINEARIZED_POSITIOn
%
%   PASSES is a struct array of the same size as LINEARIZED_POSITION.
%     'subject': inherited from LINEARIZED_POSITION
%     'day': inherited from LINEARIZED_POSITION
%     'epoch': inherited from LINEARIZED_POSITION
%     'environment': inherited from LINEARIZED_POSITION
%     'units': inherited from LINEARIZED_POSITION
%     'track_interval': inherited from PARAMS
%     'minimum_speed': inherited from PARAMS
%     'discretization_timestep': inherited from PARAMS
%     'direction': running direction, either -1 or +1
%     'timerange': 1-by-2 row vector specifying a uint32 timestamp interval,
%         encompassing the total duration of the pass.
%     'arrests': M-by-2 matrix specifying uint32 timestamp intervals within
%         'timerange' during which the rat is immobile
%     'running': N-by-2 matrix specifying uint32 timestamp intervals within
%         'timerange' during which the rat is running forward at least
%         PARAMS.minimum_speed
%     'timestamp': a column vector of uint32 timestamps corresponding to
%         position samples in LINEARIZED_POSITION which span 'timerange'
%     'position': corresponding linearized position values
%     'speed': corresponding linearized speed values, adjusted for 'direction'
%         so that positive means running forward
%
%Depends on:
%   IS_LINEARIZED (written by SMK)
%   FIND_INTERVALS (written by SMK)
%   ISMEMBER_INTERVALS (written by SMK)
%   INTERSECT_INTERVALS (written by SMK)
%   DIFF_INTERVALS (written by SMK)
%
%Written by SMK, 2009 December 14.
%

TS_PER_SEC = 1e4;

% Check dependencies
if (exist('is_linearized') ~= 2)
  error(['FIND_RUNNING_INTERVALS depends on the m-file IS_LINEARIZED ' ...
      '(written by SMK)']);
end
if (exist('is_intervals') ~= 2)
  error(['FIND_RUNNING_INTERVALS depends on the m-file IS_INTERVALS ' ...
      '(written by SMK)']);
end
if (exist('find_intervals') ~= 2)
  error(['FIND_RUNNING_INTERVALS depends on the m-file FIND_INTERVALS ' ...
      '(written by SMK)']);
end
if (exist('ismember_intervals') ~= 2)
  error(['FIND_RUNNING_INTERVALS depends on the m-file ISMEMBER_INTERVALS ' ...
      '(written by SMK)']);
end
if (exist('intersect_intervals') ~= 2)
  error(['FIND_RUNNING_INTERVALS depends on the m-file INTERSECT_INTERVALS ' ...
      '(written by SMK)']);
end
if (exist('diff_intervals') ~= 2)
  error(['FIND_RUNNING_INTERVALS depends on the m-file DIFF_INTERVALS ' ...
      '(written by SMK)']);
end

% Input checking
if ~is_linearized(linearized)
  error(['LINEARIZED must be a data struct containing linearized ' ...
      'position data']);
end
if ~isstruct(params) || ~all(isfield(params, ...
    {'track_interval','discretization_timestep','minimum_speed'}))
  error('PARAMS is not a struct or is missing one or more required fields');
end
if ~is_intervals(params.track_interval) || (size(params.track_interval,1) ~= 1)
  error(['''track_interval'' field of PARAMS must be a positive real ' ...
      'floating-point 1x2 vector that specifies a position interval']);
end
if ~isa(params.discretization_timestep,'uint32') || ...
    ~isscalar(params.discretization_timestep) || ...
    ~isreal(params.discretization_timestep) || ...
    ~(params.discretization_timestep > 0)
  error(['''discretization_timestep'' field of PARAMS must be a ' ...
    'nonzero uint32 real scalar']);
end
if ~isfloat(params.minimum_speed) || ~isscalar(params.minimum_speed) || ...
    ~isreal(params.minimum_speed) || ~isfinite(params.minimum_speed) || ...
    ~(params.minimum_speed >= 0)
  error(['''minimum_speed'' field of PARAMS must be a ' ...
    'non-negative finite floating-point real scalar']);
end

linearized_passes = struct( ...
    'subject'                 , {}, ...
    'day'                     , {}, ...
    'epoch'                   , {}, ...
    'environment'             , {}, ...
    'units'                   , {}, ...
    'track_interval'          , {}, ...
    'minimum_speed'           , {}, ...
    'discretization_timestep' , {}, ...
    'direction'               , {}, ...
    'timerange'               , {}, ...
    'timestamp'               , {}, ...
    'position'                , {}, ...
    'speed'                   , {}, ...
    'arrests'                 , {}, ...
    'backwards'               , {}, ...
    'running'                 , {}, ...
    'overall_mean_speed'      , {} );

for i = 1:numel(linearized)
  t = linearized(i).timestamp;
  x = double(linearized(i).position);
  s = double(linearized(i).speed);

  % timerange is a num_passes-by-2 matrix that specifies nonoverlapping uint32
  % timestamp intervals
  timerange = find_intervals(t,x, ...
      @(pos) ismember_intervals(pos,params.track_interval), ...
      params.discretization_timestep);
  % Remove first and/or last interval if pass was not completed
  if ~any(t < timerange(1,1))
    timerange(1,:) = [];
  end
  if ~any(t > timerange(end,2))
    timerange(end,:) = [];
  end
  % Check whether the pass starts and end at opposite ends of the track
  start_end_positions = interp1(double(t),x,double(timerange));
  valid_pass_flag = ...
      sign(start_end_positions(:,1)) == -sign(start_end_positions(:,2));
  timerange = timerange(valid_pass_flag,:);
  start_end_positions = start_end_positions(valid_pass_flag,:);
  % direction is column vector of size num_passes-by-1, in which each element
  % indicates the direction of the pass (either -1 or +1)
  direction = sign(diff(start_end_positions,1,2));
  assert(isequal(size(timerange),[numel(direction) 2]));

  for j = 1:numel(direction)
    % compute overall mean speed
    overall_mean_speed = abs(diff(params.track_interval)) / ...
        (double(diff(timerange(j,:)))/TS_PER_SEC);
    % Select linearized_position samples that span each pass
    sample_idx = ...
        find(t < timerange(j,1),1,'last'):find(t > timerange(j,2),1,'first');
    % Identify times when rat is stopped
    arrests = intersect_intervals(timerange(j,:),linearized(i).arrests);
    % Identify times when rat is moving backwards
    backwards = intersect_intervals(timerange(j,:), ...
        find_intervals(t,direction(j)*s,@(x) x < 0, ...
        params.discretization_timestep));
    % Identify times when rat is running forwards at least PARAMS.minimum_speed
    running = diff_intervals(intersect_intervals(timerange(j,:), ...
        find_intervals(t,direction(j)*s,@(x) x >= params.minimum_speed, ...
        params.discretization_timestep)), ...
        union_intervals(arrests,backwards));

    % 'speed' field of linearized_passes is corrected for direction
    linearized_passes = [ linearized_passes; struct( ...
        'subject'                 , {linearized(i).subject} , ...
        'day'                     , {linearized(i).day} , ...
        'epoch'                   , {linearized(i).epoch} , ...
        'environment'             , {linearized(i).environment}, ...
        'units'                   , {linearized(i).units}, ...
        'track_interval'          , {params.track_interval}, ...
        'minimum_speed'           , {params.minimum_speed}, ...
        'discretization_timestep' , {params.discretization_timestep}, ...
        'direction'               , {direction(j)}, ...
        'timerange'               , {timerange(j,:)}, ...
        'timestamp'               , {t(sample_idx)}, ...
        'position'                , {x(sample_idx)}, ...
        'speed'                   , {direction(j)*s(sample_idx)}, ...
        'arrests'                 , {arrests}, ...
        'backwards'               , {backwards}, ...
        'running'                 , {running}, ...
        'overall_mean_speed'      , {overall_mean_speed} ) ];
  end

end

