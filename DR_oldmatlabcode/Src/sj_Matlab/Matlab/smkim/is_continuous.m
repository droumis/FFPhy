function bool = is_continuous(continuous)
%IS_CONTINUOUS Validate whether the input is a continuous struct array
%
%   IS_CONTINUOUS(CONTINUOUS) returns true if CONTINUOUS is a struct array that
%   contains valid continuously-recorded voltage data.
%   
%   See also READ_CONTINUOUS, written by smk.
%
%Written by SMK 2009 June 22.
%

REQUIRED_FIELDS = { ...
    'subject'         , ...
    'day'             , ...
    'epoch'           , ...
    'environment'     , ...
    'electrode'       , ...
    'channel'         , ...
    'depth'           , ...
    'hemisphere'      , ...
    'region'          , ...
    'reference'       , ...
    'passband'        , ...
    'Fs'              , ...
    'timestamp'       , ...
    'samples'         , ...
    'sources'          };

TS_PER_SEC = 1e4;
SAMPRATE_TOL = 1e-4;

if isempty(continuous) && isstruct(continuous) && ...
    all(isfield(continuous,REQUIRED_FIELDS))
  warning('CONTINUOUS struct is empty');
  bool = true;

elseif ~isstruct(continuous) || ~all(isfield(continuous,REQUIRED_FIELDS))
  warning('missing required field(s)');
  bool = false;

elseif ~iscellstr({continuous(:).subject}) || ...
    ~all(strcmp({continuous(:).subject}, ...
    regexp({continuous(:).subject},'[a-zA-Z0-9]*','match','once')))
  warning(['subject field must be a string containing characters ' ...
      '[a-zA-Z0-9]']);
  bool = false;

elseif ~all(cellfun(@isnumeric,{continuous(:).day})) || ...
    ~all(cellfun(@isscalar,{continuous(:).day})) || ...
    ~all(cellfun(@isreal,{continuous(:).day})) || ...
    ~all(cellfun(@isfinite,{continuous(:).day})) || ...
    ~all(cellfun(@(c) (c >= 0),{continuous(:).day})) || ...
    ~all(cellfun(@(c) (round(c) == c),{continuous(:).day}))
  warning('day field must be a real non-negative integer scalar');
  bool = false;

elseif ~iscellstr({continuous(:).epoch}) || ...
    ~all(strcmp({continuous(:).epoch}, ...
    regexp({continuous(:).epoch},'[a-zA-Z0-9]*','match','once')))
  warning(['epoch field must be a string containing characters ' ...
      '[a-zA-Z0-9]']);
  bool = false;

elseif ~iscellstr({continuous(:).environment}) || ...
    ~all(strcmp({continuous(:).environment}, ...
    regexp({continuous(:).environment},'[a-zA-Z0-9]*','match','once')))
  warning(['environment field must be a string containing characters ' ...
      '[a-zA-Z0-9]']);
  bool = false;

elseif ~all(cellfun(@isnumeric,{continuous(:).electrode})) || ...
    ~all(cellfun(@isscalar,{continuous(:).electrode})) || ...
    ~all(cellfun(@isreal,{continuous(:).electrode})) || ...
    ~all(cellfun(@isfinite,{continuous(:).electrode})) || ...
    ~all(cellfun(@(c) (c > 0),{continuous(:).electrode})) || ...
    ~all(cellfun(@(c) (round(c) == c),{continuous(:).electrode}))
  warning('electrode field must be a real positive integer scalar');
  bool = false;

elseif ~all(cellfun(@isnumeric,{continuous(:).channel})) || ...
    ~all(cellfun(@isscalar,{continuous(:).channel})) || ...
    ~all(cellfun(@isreal,{continuous(:).channel})) || ...
    ~all(cellfun(@isfinite,{continuous(:).channel})) || ...
    ~all(cellfun(@(c) (c >= 0),{continuous(:).channel})) || ...
    ~all(cellfun(@(c) (round(c) == c),{continuous(:).channel}))
  warning('channel field must be a non-negative integer scalar');
  bool = false;

elseif ~all(cellfun(@isnumeric,{continuous(:).depth})) || ...
    ~all(cellfun(@isscalar,{continuous(:).depth})) || ...
    ~all(cellfun(@isreal,{continuous(:).depth})) || ...
    ~all(cellfun(@isfinite,{continuous(:).depth})) || ...
    ~all(cellfun(@(c) (round(c) == c),{continuous(:).depth}))
  warning('depth field must be an integer scalar');
  bool = false;

elseif ~iscellstr({continuous(:).hemisphere}) || ...
    ~all(strcmp({continuous(:).hemisphere}, ...
    regexp({continuous(:).hemisphere},'[a-zA-Z0-9_]*','match','once')))
  warning(['hemisphere field must be a string containing characters ' ...
      '[a-zA-Z0-9_]']);
  bool = false;

elseif ~iscellstr({continuous(:).region}) || ...
    any(cellfun(@isempty,{continuous(:).region}))
  warning(['region field must be a non-empty string']);
  bool = false;

elseif ~all(cellfun(@isnumeric,{continuous(:).reference})) || ...
    ~all(cellfun(@isvector,{continuous(:).reference})) || ...
    ~all(cellfun(@(c) (size(c,1) == 1),{continuous(:).reference})) || ...
    ~all(cellfun(@(c) (size(c,2) == 2),{continuous(:).reference})) || ...
    ~all(cellfun(@(c) isreal(c),{continuous(:).reference})) || ...
    ~all(cellfun(@(c) (c(1) >= 0),{continuous(:).reference})) || ...
    ~all(cellfun(@(c) (c(2) >= 0),{continuous(:).reference}))
  warning(['reference field must be a 2-element row vector of real ' ...
      'non-negative integer values']);
  bool = false;

elseif ~all(cellfun(@isnumeric,{continuous(:).passband})) || ...
    ~all(cellfun(@isvector,{continuous(:).passband})) || ...
    ~all(cellfun(@(c) (size(c,1) == 1),{continuous(:).passband})) || ...
    ~all(cellfun(@(c) (size(c,2) == 2),{continuous(:).passband})) || ...
    ~all(cellfun(@(c) isreal(c),{continuous(:).passband})) || ...
    ~all(cellfun(@(c) all(c > 0),{continuous(:).passband})) || ...
    ~all(cellfun(@(c) c(2) > c(1),{continuous(:).passband}))
  warning(['passband field must be a 2-element row vector of real ' ...
      'positive values in increasing order']);
  bool = false;

elseif ~all(cellfun(@isnumeric,{continuous(:).timestamp})) || ...
    ~all(cellfun(@(c) isa(c,'uint32'),{continuous(:).timestamp})) || ...
    ~all(cellfun(@isvector,{continuous(:).timestamp})) || ...
    ~all(cellfun(@(c) (size(c,2) == 1),{continuous(:).timestamp})) || ...
    ~all(cellfun(@(c) isreal(c),{continuous(:).timestamp})) || ...
    ~all(cellfun(@(c) all(diff(c) >= 0),{continuous(:).timestamp}))
  warning(['timestamp field must be a column vector of ' ...
      'monotonically increasing real uint32 timestamps']);
  bool = false;

elseif ~all(cellfun(@isnumeric,{continuous(:).Fs})) || ...
    ~all(cellfun(@isscalar,{continuous(:).Fs})) || ...
    ~all(cellfun(@(c) isa(c,'double'),{continuous(:).Fs})) || ...
    ~all(cellfun(@isreal,{continuous(:).Fs})) || ...
    ~all(cellfun(@isfinite,{continuous(:).Fs})) || ...
    ~all(cellfun(@(c) (c > 0),{continuous(:).Fs}))
  warning('Fs field must be a real positive double scalar');
  bool = false;

elseif ~all(arrayfun(@(c) ...
    max(diff(c.timestamp)) <= uint32(ceil(TS_PER_SEC/c.Fs)) && ...
    min(diff(c.timestamp)) >= uint32(floor(TS_PER_SEC/c.Fs)) && ...
    abs(mean(double(diff(c.timestamp)))*c.Fs/TS_PER_SEC - 1) < SAMPRATE_TOL,...
    continuous))
  warning(['spacing of values in timestamp field is not consistent with' ...
      'sampling rate']);
  bool = false;

elseif ~all(cellfun(@isnumeric,{continuous(:).samples})) || ...
    ~all(cellfun(@isvector,{continuous(:).samples})) || ...
    ~all(cellfun(@(c) isa(c,'float'),{continuous(:).samples})) || ...
    ~all(cellfun(@(c) all(isfinite(c)),{continuous(:).samples}))
  warning('samples field must be a vector of finite floating-point values');
  bool = false;

elseif arrayfun(@(s) numel(s.timestamp) ~= numel(s.samples),continuous)
  warning('number of samples must match number of timestamps');
  bool = false;

elseif ~all(cellfun(@iscellstr,{continuous(:).sources})) || ...
    ~all(cellfun(@(c) all(cellfun(@exist,c) == 2), ...
    {continuous(:).sources})) || ...
    ~all(cellfun(@(c) all(cellfun(@(cc) isdir(fileparts(cc)),c)), ...
    {continuous(:).sources}))
  warning(['sources field must be a cell array of strings that specify ' ...
      'filenames, including path']);
  bool = false;

else
  [i1, i2] = ndgrid(1:numel(continuous));
  pair_idx = find(i1 ~= i2);
  i1 = i1(pair_idx);
  i2 = i2(pair_idx);
  % Check that no two elements of continuous duplicate the same
  % (subject, day, epoch, electrode, channel) 5-tuple
  if any(arrayfun(@(s1,s2) isequal( ...
      {s1.subject, s1.day, s1.epoch, s1.electrode, s1.channel}, ...
      {s2.subject, s2.day, s2.epoch, s2.electrode, s1.channel}), ...
      continuous(i1),continuous(i2)))
    warning(['continuous data structs in the same array have duplicate ' ...
        'information for the same recording channel']);
    bool = false;
  % Check that no two elements of continuous which share the same 
  % (subject, day, electrode) 3-tuple have discrepant depth or region fields
  elseif any( arrayfun(@(s1,s2) isequal( ...
      {s1.subject, s1.day, s1.electrode}, ...
      {s2.subject, s2.day, s2.electrode}),continuous(i1),continuous(i2)) & ...
      arrayfun(@(s1,s2) ...
      ~isequal(s1.depth,s2.depth) || ~isequal(s1.region,s2.region), ...
      continuous(i1),continuous(i2)) )
    warning(['continuous data structs in the same array have discrepant ' ...
        'recording locations for the same electrode']);
    bool = false;
  % Check that no two elements of continuous which share the same 
  % (subject, day, electrode, channel) 4-tuple have overlapping timestamps
  elseif any( arrayfun(@(s1,s2) isequal( ...
      {s1.subject, s1.day, s1.electrode, s1.channel}, ...
      {s2.subject, s2.day, s2.electrode, s1.channel}), ...
      continuous(i1),continuous(i2)) & ...
      arrayfun(@(s1,s2) ...
      ~((s1.timestamp(end) < s2.timestamp(1)) || ...
      (s1.timestamp(1) > s2.timestamp(end))),continuous(i1),continuous(i2)) )
    warning(['continuous data structs in the same array have overlapping ' ...
        'timestamps']);
    bool = false;
  else
    bool = true;
  end

end

