function bool = is_dio(dio)
%IS_DIO Validate whether the input is an digital I/O struct array
%
%   IS_DIO(DIO) returns true if DIO is a struct array that contains valid
%   digital input/output signal data.
%   
%   See also READ_DIO, written by smk.
%
%
%Written by SMK 2009 June 22.
%

REQUIRED_FIELDS = { ...
    'subject'    , ...
    'day'        , ...
    'epoch'      , ...
    'environment', ...
    'timerange'  , ...
    'timestamp'  , ...
    'status'     , ...
    'ports'      , ...
    'source'     };

if isempty(dio) && isstruct(dio) && all(isfield(dio,REQUIRED_FIELDS))
  warning('DIO struct is empty');
  bool = true;

elseif ~isstruct(dio) || ~all(isfield(dio,REQUIRED_FIELDS))
  warning('missing required field(s)');
  bool = false;

elseif ~iscellstr({dio(:).subject}) || ...
    ~all(strcmp({dio(:).subject}, ...
    regexp({dio(:).subject},'[a-zA-Z0-9]*','match','once')))
  warning(['subject field must be a string containing characters ' ...
      '[a-zA-Z0-9]']);
  bool = false;

elseif ~all(cellfun(@isnumeric,{dio(:).day})) || ...
    ~all(cellfun(@isscalar,{dio(:).day})) || ...
    ~all(cellfun(@isreal,{dio(:).day})) || ...
    ~all(cellfun(@isfinite,{dio(:).day})) || ...
    ~all(cellfun(@(c) (c >= 0),{dio(:).day})) || ...
    ~all(cellfun(@(c) (round(c) == c),{dio(:).day}))
  warning('day field must be a real non-negative integer scalar');
  bool = false;

elseif ~iscellstr({dio(:).epoch}) || ...
    ~all(strcmp({dio(:).epoch}, ...
    regexp({dio(:).epoch},'[a-zA-Z0-9]*','match','once')))
  warning(['epoch field must be a string containing characters ' ...
      '[a-zA-Z0-9]']);
  bool = false;

elseif ~iscellstr({dio(:).environment}) || ...
    ~all(strcmp({dio(:).environment}, ...
    regexp({dio(:).environment},'[a-zA-Z0-9]*','match','once')))
  warning(['environment field must be a string containing characters ' ...
      '[a-zA-Z0-9]']);
  bool = false;

elseif ~all(cellfun(@is_timerange,{dio(:).timerange}))
  warning('timerange field must be valid uint32 timestamp interval set');
  bool = false;

elseif ~all(cellfun(@isnumeric,{dio(:).timestamp})) || ...
    ~all(cellfun(@(c) isa(c,'uint32'),{dio(:).timestamp})) || ...
    ~all(cellfun(@isvector,{dio(:).timestamp})) || ...
    ~all(cellfun(@(c) (size(c,2) == 1),{dio(:).timestamp})) || ...
    ~all(cellfun(@(c) isreal(c),{dio(:).timestamp})) || ...
    ~all(cellfun(@(c) all(diff(c) >= 0),{dio(:).timestamp}))
  warning(['timestamp field must be a column vector of monotonically ' ...
      'increasing real uint32 timestamps']);
  bool = false;

elseif ~all(cellfun(@isnumeric,{dio(:).status})) || ...
    ~all(cellfun(@(c) isa(c,'uint16'),{dio(:).status})) || ...
    ~all(cellfun(@(c) (ndims(c) == 2),{dio(:).status})) || ...
    ~all(cellfun(@(c) isreal(c),{dio(:).status}))
  warning('status field must be an array of uint16 values');
  bool = false;

elseif ~all(cellfun(@(c) iscellstr(c),{dio(:).ports})) || ...
    ~all(cellfun(@(c) all(strcmp('input',c) | strcmp('output',c)), ...
    {dio(:).ports}))
  warning(['ports field must be a cell array of strings that match either ' ...
      '"input" or "output"']);
  bool = false;

elseif ~all(arrayfun(@(s) size(s.status,2) == numel(s.ports),dio))
  warning('status field and ports field must agree in size')
  bool = false;

elseif ~all(arrayfun(@(s) size(s.status,1) == numel(s.timestamp),dio))
  warning('status field and timestamp field must agree in size')
  bool = false;

elseif ~iscellstr({dio(:).source}) || ...
    ~all(cellfun(@(c) (exist(c) == 2),{dio(:).source})) || ...
    ~all(cellfun(@(c) isdir(fileparts(c)),{dio(:).source}))
  warning(['source field must be a string that specifies a filename, ' ...
      'including path']);
  bool = false;

else
  [i1, i2] = ndgrid(1:numel(dio));
  pair_idx = find(i1 ~= i2);
  i1 = i1(pair_idx);
  i2 = i2(pair_idx);

  % Check that no two elements of dio duplicate the same
  % (subject, day, epoch) 3-tuple
  if any(arrayfun(@(s1,s2) isequal( ...
      {s1.subject, s1.day, s1.epoch}, ...
      {s2.subject, s2.day, s2.epoch}),dio(i1),dio(i2)))
    bool = false;
  % Check that no two elements of dio which share the same (subject, day)
  % 2-tuple have overlapping timestamps
  elseif any( arrayfun(@(s1,s2) isequal( ...
      {s1.subject, s1.day},{s2.subject, s2.day}),dio(i1),dio(i2)) & ...
      arrayfun(@(s1,s2) ~isempty(s1.timestamp) && ~isempty(s2.timestamp) && ...
      ~(all(s1.timestamp < min(s2.timestamp)) || ...
      all(s1.timestamp > max(s2.timestamp))),dio(i1),dio(i2)) )
    bool = false;
  else
    bool = true;
  end

end

