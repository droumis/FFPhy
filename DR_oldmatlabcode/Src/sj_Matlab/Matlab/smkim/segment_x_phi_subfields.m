function subfields = segment_x_phi_subfields(receptive_fields,params)
%
%   SUBFIELDS = SEGMENT_X_PHI_SUBFIELDS(RECEPTIVE_FIELDS,PARAMS) takes a struct
%   RECEPTIVE_FIELDS that contains a linearized position/phase receptive-field
%   estimate of the type returned by X_PHI_RECEPTIVE_FIELD and segments it into
%   subfields.
%
%   PARAMS must have the following fields:
%     'minimum_peak_firing_rate': peak firing rate must be greater than or equal to
%         this value for the subfield to be indentified
%     'baseline_fraction': a fraction greater than zero and less than unity
%     'minimum_field_length': minimum width of the field along the linearized
%         position dimension, expressed in the same units as
%         RECEPTIVE_FIELDS.grid.x
%
%   Output struct SUBFIELDS has the following fields, one element per each
%   segmented field:
%     'uid'                         , {}, ...
%     'region'                      , {}, ...
%     'hemisphere'                  , {}, ...
%     'subject'                     , {}, ...
%     'tetrode'                     , {}, ...
%     'depth'                       , {}, ...
%     'reference'                   , {}, ...
%     'clustnum'                    , {}, ...
%     'cluster_quality'             , {}, ...
%     'day'                         , {}, ...
%     'epoch'                       , {}, ...
%     'environment'                 , {}, ...
%     'direction'                   , {}, ...
%     'timerange'                   , {}, ...
%     'lfp'                         , {}, ...
%     'contour'                     , {}, ...
%     'peak_firing_rate'            , {}, ...
%     'baseline_fraction'           , {}, ...
%     'position_COM'                , {}, ...
%     'phase_COM'                   , {}, ...
%     'field_length'                , {}, ...
%     'phase_precession_slope'      , {}, ...
%     'phase_precession_slope_units', {}, ...
%     'correlation_coefficient'     , {}, ...
%     'jackknife_correlation_coefficient' , {}, ...
%     'signficance_level'           , {} );
%
%Depends on:
%   IMHMAX (MATLAB Image Processing Toolbox)
%   IMRECONSTRUCT (MATLAB Image Processing Toolbox)
%   BWPERIM (MATLAB Image Processing Toolbox)
%   WATERSHED (MATLAB Image Processing Toolbox)
%   LSQCURVEFIT (MATLAB Optimization Toolbox)
%   OPTIMSET (MATLAB Optimization Toolbox)
%
%Written by SMK, 2010 March 8.
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TODO: write a validation function for the receptive_fields data struct

if (exist('interp2_cylinder') ~= 2)
  error(['SEGMENT_X_PHI_SUBFIELDS depends on m-file ' ...
      'INTERP2_CYLINDER (written by SMK)']);
end
if (exist('imhmax') ~= 2)
  error(['SEGMENT_X_PHI_SUBFIELDS depends on m-file ' ...
      'IMHMAX (MATLAB Image Processing toolbox)']);
end
if (exist('imreconstruct') ~= 2)
  error(['SEGMENT_X_PHI_SUBFIELDS depends on m-file ' ...
      'IMRECONSTRUCT (MATLAB Image Processing toolbox)']);
end
if (exist('bwperim') ~= 2)
  error(['SEGMENT_X_PHI_SUBFIELDS depends on m-file ' ...
      'BWPERIM (MATLAB Image Processing toolbox)']);
end
if (exist('watershed') ~= 2)
  error(['SEGMENT_X_PHI_SUBFIELDS depends on m-file ' ...
      'WATERSHED (MATLAB Image Processing toolbox)']);
end
if (exist('lsqcurvefit') ~= 2)
  error(['SEGMENT_X_PHI_SUBFIELDS depends on m-file ' ...
      'LSQCURVEFIT (MATLAB Optimization toolbox)']);
end
if (exist('optimset') ~= 2)
  error(['SEGMENT_X_PHI_SUBFIELDS depends on m-file ' ...
      'OPTIMSET (MATLAB Optimization toolbox)']);
end

if ~isstruct(receptive_fields) || ~all(isfield(receptive_fields, ...
    {'uid','region','hemisphere','subject','tetrode','depth', ...
    'reference','clustnum','cluster_quality','day','epoch','environment', ...
    'direction','lfp','timerange','position_units', ...
    'grid','firing_rate'}))
  error('RECEPTIVE_FIELDS is not a valid struct');
end
if any(arrayfun(@(r) ~isstruct(r.grid) || ...
    ~all(isfield(r.grid,{'x','phi'})) || ...
    ~isvector(r.grid.phi) || (size(r.grid.phi,1) > size(r.grid.phi,2)) || ...
    ~isvector(r.grid.x) || (size(r.grid.x,1) < size(r.grid.x,2)), ...
    receptive_fields))
  error('''grid'' field of RECEPTIVE_FIELDS is not valid');
end
if any(arrayfun(@(r) (ndims(r.firing_rate) ~= 2) || ...
    ~isfloat(r.firing_rate) || ~all(isfinite(r.firing_rate(:))) || ...
    (size(r.firing_rate,1) ~= numel(r.grid.x)) || ...
    (size(r.firing_rate,2) ~= numel(r.grid.phi)),receptive_fields))
  error(['''firing_rate'' field of RECEPTIVE_FIELDS is not valid or ' ...
      'does not match ''grid'' field']);
end
if any(arrayfun(@(r) ~isscalar(r.direction) || ~isreal(r.direction) || ...
    ~any(r.direction == [+1, -1]),receptive_fields))
  error(['''direction'' field of RECEPTIVE_FIELDS must equal ' ...
    '+1 (rightbound) or -1 (leftbound)']);
end

if ~isstruct(params) || ~isscalar(params) || ~all(isfield(params, ...
    {'minimum_peak_firing_rate','baseline_fraction','minimum_field_length'}))
  error('PARAMS is not a scalar struct or is missing required field(s)');
end
if ~isscalar(params.minimum_peak_firing_rate) || ...
    ~isreal(params.minimum_peak_firing_rate) || ...
    ~isfloat(params.minimum_peak_firing_rate) || ...
    ~isfinite(params.minimum_peak_firing_rate) || ...
    (params.minimum_peak_firing_rate <= 0)
  error('PARAMS.minimum_peak_firing_rate must be a positive real finite scalar');
end
if ~isscalar(params.baseline_fraction) || ...
    ~isreal(params.baseline_fraction) || ...
    ~isfloat(params.baseline_fraction) || ...
    ~isfinite(params.baseline_fraction) || ...
    (params.baseline_fraction <= 0) || (params.baseline_fraction >= 1)
  error(['PARAMS.baseline_fraction must be a positive real scalar ' ...
      'greater than zero and less than one']);
end
if ~isscalar(params.minimum_field_length) || ...
    ~isreal(params.minimum_field_length) || ...
    ~isfloat(params.minimum_field_length) || ...
    ~isfinite(params.minimum_field_length) || ...
    ~(params.minimum_field_length > 0)
  error(['PARAMS.minimum_field_length must be a positive real scalar']);
end

% Allocate output struct
subfields = struct( ...
    'uid'                         , {}, ...
    'region'                      , {}, ...
    'hemisphere'                  , {}, ...
    'subject'                     , {}, ...
    'tetrode'                     , {}, ...
    'depth'                       , {}, ...
    'reference'                   , {}, ...
    'clustnum'                    , {}, ...
    'cluster_quality'             , {}, ...
    'day'                         , {}, ...
    'epoch'                       , {}, ...
    'environment'                 , {}, ...
    'direction'                   , {}, ...
    'timerange'                   , {}, ...
    'lfp'                         , {}, ...
    'contour'                     , {}, ...
    'peak_firing_rate'            , {}, ...
    'baseline_fraction'           , {}, ...
    'position_COM'                , {}, ...
    'phase_COM'                   , {}, ...
    'field_length'                , {}, ...
    'phase_precession_slope'      , {}, ...
    'phase_precession_slope_units', {}, ...
    'correlation_coefficient'     , {}, ...
    'jackknife_correlation_coefficient' , {}, ...
    'p_value'                     , {} );
      
% options for LSQCURVEFIT
options = optimset('FunValCheck','on','Diagnostics','off', ...
    'MaxFunEvals',1e4,'MaxIter',1e3,'TolFun',1e-4, ...
    'Display','off');

for n = 1:numel(receptive_fields)
  r = receptive_fields(n);

  % Tile the receptive field 5-fold along the phase dimension. We want to ensure
  % that we capture the entire field if it spans more than 2*pi phase, without
  % having to worry about boundary conditions.
  [tiled.x, tiled.phi] = ndgrid( ...
      r.grid.x, ...
      [r.grid.phi-4*pi, r.grid.phi-2*pi, r.grid.phi, ...
      r.grid.phi+2*pi, r.grid.phi+4*pi] );
  tiled.firing_rate = repmat(r.firing_rate,[1 5]);
  assert(isequal(size(tiled.x),size(tiled.phi),size(tiled.firing_rate)));
  tiled.sz = size(tiled.firing_rate);

  % Logical matrix of initially blacklisted pixels
  blacklist = (tiled.firing_rate <= ...
      params.minimum_peak_firing_rate*params.baseline_fraction);
  % Find all local maxima in the interpolated image
  candidates = find(imregionalmax(tiled.firing_rate));
  % Cull the candidates that lie at the edges of the x range or that lie outside 
  % the canonical phase range [-pi,+pi].
  x_min = r.grid.x(1);
  x_max = r.grid.x(end);
  phi_min = -pi;
  phi_max = +pi;
  candidates( ...
      (tiled.phi(candidates) < phi_min) | ...
      (tiled.phi(candidates) > phi_max) | ...
      (tiled.x(candidates) <= x_min) | ...
      (tiled.x(candidates) >= x_max) ) = [];
  % Also cull those candidates whose values are below minimum criterion
  candidates( ...
      tiled.firing_rate(candidates) < params.minimum_peak_firing_rate) = [];
  % Sort the candidates by peak firing rate in descending order
  [sort_val, sort_idx] = sort(tiled.firing_rate(candidates),'descend');
  candidates = candidates(sort_idx);

  %{
  % DEBUG
  subplot(2,1,1);
  imagesc(tiled.x(:,1),tiled.phi(1,:),tiled.firing_rate');
  colorbar;
  set(gca,'YDir','normal');
  %}

  while ~isempty(candidates)
    % Sentinel value for whether to include this peak
    valid = true;
    % Get peak firing rate and baseline threshold for the highest-ranked
    % candidate
    peak = tiled.firing_rate(candidates(1));
    baseline = params.baseline_fraction*peak;
    % Suppress small maxima using h-maxima transform, with parameter equal to
    % the baseline threshold
    h = imhmax(tiled.firing_rate,baseline,8);
    % Flood-fill to find the contiguous region of above-baseline pixels around
    % the peak. This is the candidate field.
    seed = false(tiled.sz);
    seed(candidates(1)) = true;
    mask = imreconstruct(seed,h > baseline,8);
    % Get pixels that fall inside the field
    field.x = tiled.x(mask);
    field.phi = tiled.phi(mask);
    field.firing_rate = tiled.firing_rate(mask);
    % Check the goodness of this segmentation:
    if isempty(mask)
      % Does the segmented field stand out from adequately from background?
      valid = false;
    elseif any(any(mask & blacklist,1),2)
      % Does the segmented field overlap with already blacklisted pixels?
      valid = false;
    elseif ...
      any(any(mask & circshift(mask,[0, -tiled.sz(2)/5]),1),2) || ...
      any(any(mask & circshift(mask,[0, +tiled.sz(2)/5]),1),2)
      % Is the segmented field periodic in phase? 
      valid = false;
    elseif any(field.x <= x_min) || any(field.x >= x_max)
      % Is the segmented field truncated at x_min or x_max?
      valid = false;
    else
      % Find watershed contours of the masked h-maxima transformed surface to
      % determine whether saddle ridges intersect the segmented contour; if so,
      % then the segmented field is not unimodal
      if any(any(bwperim(mask,8) & ...
          (watershed(-max(baseline,h .* double(mask)),8) == 0),1),2)
        valid = false;
      end
    end
    % Contour along the boundary. This should be a simple closed contour,
    % because we've already checked that the field does not extend all the way
    % to x_min or x_max along the x-dimension and is well-localized to a single
    % period along the phase dimension.
    c = contourc(tiled.x(:,1),tiled.phi(1,:), ...
        (tiled.firing_rate .* double(mask))',[baseline baseline]);
    % Compute field length from the contour. This is a little bit tricky because
    % of the structure of the contour matrix.
    field_length = get_field_length_from_contour(c);
    % Check for minimum width and skip if the field is too small
    if (field_length < params.minimum_field_length)
      valid = false;
    end

    if (valid)
      assert(all(field.firing_rate >= 0));
      assert(isequal(size(field.x),size(field.phi),size(field.firing_rate), ...
          [numel(field.x) 1]));
      % Fit a Gaussian to the firing rate within the masked region, as if it
      % were a probability distribution whose density function is proportional
      % to firing rate. Find the correlation matrix of this Gaussian (i.e.
      % after standardizing so that the marginal variances are unity). We fit a
      % Gaussian instead of estimating the correlation matrix directly from the
      % segmented place field because the Gaussian fit more robustly captures
      % overall shape and is not as sensitive to censoring along the boundary.
      % @weighted_2d_stats and @gaussian_2d are defined as a separate
      % subfunctions in this m-file.
      [mu, sigma] = weighted_2d_stats(field.x,field.phi,field.firing_rate);
      initial_fit = [ peak, mu(1), mu(2), ...
          sqrt(sigma(1,1)), sqrt(sigma(2,2)), ...
          sigma(1,2)/sqrt(sigma(1,1)*sigma(2,2)) ];
      lb = [ baseline, min(field.x), min(field.phi), ...
          mean(diff(tiled.x(:,1))), +eps, -1 ];
      ub = [ 3*peak, max(field.x), max(field.phi), ...
          range(tiled.x(:,1)), 4*pi, +1 ];
      fit = lsqcurvefit(@gaussian_2d,initial_fit, ...
          [field.x, field.phi],field.firing_rate,lb,ub,options);
      mu = [fit(2), fit(3)];
      rho = fit(6);
      assert(isfinite(rho) && (abs(rho) <= 1));
      sd = [ fit(4); fit(5) ];
      % Use jackknifed estimates of receptive field to test statistical
      % significance of correlation coefficient
      rho_jackknife = nan([size(r.jackknife_coefficients,4), 1]);
      for p = 1:numel(rho_jackknife);
        tiled.jackknife_firing_rate = repmat( ...
            exp(r.jackknife_coefficients(:,:,1,p)),[1 5]);
        if any(isnan(tiled.jackknife_firing_rate(:)))
          continue;
        end
        jackknife_fit = lsqcurvefit(@gaussian_2d,initial_fit, ...
            [field.x, field.phi],tiled.jackknife_firing_rate(mask), ...
            lb,ub,options);
        rho_jackknife(p) = jackknife_fit(6);
      end
      % WTF why are there NaNs in the jackknife estimates of the coefficients?!
      rho_jackknife(isnan(rho_jackknife)) = [];
      num_jackknife = numel(rho_jackknife);
      assert(all(isfinite(rho_jackknife) & (abs(rho_jackknife) <= 1)));
      % Compute approximate studentized p-value. Apply Fisher transformation to
      % pseudovalues, get jackknife estimate of variance, and standardize to
      % obtain t-statistic.
      z = atanh(rho_jackknife);
      t = mean(z)/sqrt((num_jackknife-1)/num_jackknife*sum((z - mean(z)).^2));
      p_value = 1 - abs(diff(tcdf([-t, +t],num_jackknife-1)));
      disp([p_value, r.direction*rho]);
      % Get larger eigenvector of the correlation matrix.
      eigvec = pcacov([1, rho; rho, 1]);
      eigvec = diag(sd) * eigvec(:,1) * sign(eigvec(1,1));
      assert(sign(rho) == sign(eigvec(2)/eigvec(1)));
      % Get slope in degrees/cm
      phase_precession_slope = sign(r.direction)*180/pi*eigvec(2)/eigvec(1);
      % Append to output
      subfields = [ subfields; struct( ...
          'uid'                         , {r.uid}, ...
          'region'                      , {r.region}, ...
          'hemisphere'                  , {r.hemisphere}, ...
          'subject'                     , {r.subject}, ...
          'tetrode'                     , {r.tetrode}, ...
          'depth'                       , {r.depth}, ...
          'reference'                   , {r.reference}, ...
          'clustnum'                    , {r.clustnum}, ...
          'cluster_quality'             , {r.cluster_quality}, ...
          'day'                         , {r.day}, ...
          'epoch'                       , {r.epoch}, ...
          'environment'                 , {r.environment}, ...
          'direction'                   , {r.direction}, ...
          'timerange'                   , {r.timerange}, ...
          'lfp'                         , {r.lfp}, ...
          'contour'                     , {c}, ...
          'peak_firing_rate'            , {peak}, ...
          'baseline_fraction'           , {params.baseline_fraction}, ...
          'position_COM'                , {mu(1)}, ...
          'phase_COM'                   , {mu(2)}, ...
          'field_length'                , {field_length}, ...
          'phase_precession_slope'      , {phase_precession_slope}, ...
          'phase_precession_slope_units', ...
          {['degrees/' r.position_units]}, ...
          'correlation_coefficient'     , {rho}, ...
          'jackknife_correlation_coefficient' , {rho_jackknife}, ...
          'p_value'                     , {p_value} ) ];
    end
    % Add all pixels within this region (and periodic phase-shifted copies) to
    % the blacklist
    blacklist = blacklist | mask | ...
        circshift(mask,[0,-2/5*tiled.sz(2)]) | ...
        circshift(mask,[0,-1/5*tiled.sz(2)]) | ...
        circshift(mask,[0,+1/5*tiled.sz(2)]) | ...
        circshift(mask,[0,+2/5*tiled.sz(2)]);

    %{ 
    % DEBUG
    subplot(2,1,1);
    contourc_lines(c,'Color','w');
    if (valid)
      subplot(2,1,1);
      line(tiled.x(candidates(1)),tiled.phi(candidates(1)), ...
          'Marker','o','MarkerSize',10,'Color','w');
      line(mu(1) + field_length*[-0.5 +0.5], ...
          mu(2) + field_length*[-0.5 +0.5]*r.direction*phase_precession_slope*pi/180, ...
          'Color','w');
      %
      subplot(2,1,2);
      imagesc(tiled.x(:,1),tiled.phi(1,:), ...
          reshape(gaussian_2d(fit,[tiled.x(:), tiled.phi(:)]), ...
          tiled.sz)');
      set(gca,'CLim',[0 max(tiled.firing_rate(:))],'YDir','normal');
      colorbar;
      contourc_lines(c,'Color','w');
      %
    else
      subplot(2,1,1);
      line(tiled.x(candidates(1)),tiled.phi(candidates(1)), ...
          'Marker','x','MarkerSize',10,'Color','k');
    end
    %}
    
    % Remove all blacklisted pixels from the list of candidates
    candidates(blacklist(candidates)) = [];
  end

  %{
  % DEBUG
  pause;
  delete(gcf);    
  %}

end

end % end main function

% Mean and covariance from two-dimensional binned histogram data
function [mu, sigma] = weighted_2d_stats(x,phi,weights)
  % x, phi, weights must all be column vectors of the same size. weights must be
  % positive. there is no error checking.
  sum_weights = sum(weights);
  mu = [sum(x.*weights), sum(phi.*weights)]/sum_weights;
  if (nargout > 1)
    c = bsxfun(@minus,[x, phi],mu);
    sigma = bsxfun(@times,weights,c)'*c/sum_weights;
  end
end

% Two-dimensional zero-mean Gaussian function (not a proper normalized
% probability density)
function f = gaussian_2d(params,data)
  %            1  2     3       4        5          6
  % params = [ A, mu_x, mu_phi, sigma_x, sigma_phi, rho ]
  %
  % data = [ x(:), phi(:) ]
  %
  % f = A * exp( -(((x - mu_x)/sigma_x).^2 + ((phi - mu_phi)/sigma_phi).^2 ...
  %     -2*rho*(x - mu_x).*(phi - mu_phi)/(sigma_x*sigma_phi)) / ...
  %     (2*(1 - rho^2)) )
  c_x = data(:,1)-params(2);
  c_phi = data(:,2)-params(3);
  f = params(1) * exp( -((c_x/params(4)).^2 + (c_phi/params(5)).^2 ...
      -2*params(6)*(c_x.*c_phi/params(4)/params(5))) / ...
      (2*(1 - params(6)^2)) );
end

% Get x-coordinates along contour
function [field_length, x] = get_field_length_from_contour(c);
% C is a 2-by-N contour matrix of the type returned by CONTOURC. There is no
% input checking!
  x = [];
  levels = [];
  i = 1;
  while (i < size(c,2))
    levels(end+1) = c(1,i);
    n = c(2,i);
    if ~isfinite(n) || (round(n) ~= n)
      error('C is not a valid contour matrix');
    end
    j = i + (1:n);
    x = [ x; c(1,j)' ];
    i = i + n + 1;
  end
  field_length = range(x);
end



    

