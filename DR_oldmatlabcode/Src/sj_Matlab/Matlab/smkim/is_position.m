function bool = is_position(position)
%IS_POSITION Validate whether the input is a position estimate struct array.
%
%   IS_POSITION(POSITION) returns true if POSITION is a struct array of the type
%   returned by ESTIMATE_POSITION which contains head-tracking data in
%   real-world coordinates.
%   
%   See also ESTIMATE_POSITION.
%
%Written by SMK 2009 June 22.
%

% Is there some way to access the original mpeg video frames?
REQUIRED_FIELDS = { ...
    'subject'         , ...
    'day'             , ...
    'epoch'           , ...
    'environment'     , ...
    'timestamp'       , ...
    'x'               , ...
    'y'               , ...
    'x_velocity'      , ...
    'y_velocity'      , ...
    'head_direction'  , ...
    'stopped'         , ...
    'units'           , ...
    'params'          , ...
    'transform'       };

if isempty(position) && isstruct(position) && ...
    all(isfield(position,REQUIRED_FIELDS))
  warning('HEADTRACK struct is empty');
  bool = true;

elseif ~isstruct(position) || ~all(isfield(position,REQUIRED_FIELDS))
  warning('missing required field(s)');
  bool = false;

elseif ~iscellstr({position(:).subject}) || ...
    ~all(strcmp({position(:).subject}, ...
    regexp({position(:).subject},'[a-zA-Z0-9]*','match','once')))
  warning(['subject field must be a string containing characters ' ...
      '[a-zA-Z0-9]']);
  bool = false;

elseif ~all(cellfun(@isnumeric,{position(:).day})) || ...
    ~all(cellfun(@isscalar,{position(:).day})) || ...
    ~all(cellfun(@isreal,{position(:).day})) || ...
    ~all(cellfun(@isfinite,{position(:).day})) || ...
    ~all(cellfun(@(c) (c >= 0),{position(:).day})) || ...
    ~all(cellfun(@(c) (round(c) == c),{position(:).day}))
  warning('day field must be a real non-negative integer scalar');
  bool = false;

elseif ~iscellstr({position(:).epoch}) || ...
    ~all(strcmp({position(:).epoch}, ...
    regexp({position(:).epoch},'[a-zA-Z0-9]*','match','once')))
  warning(['epoch field must be a string containing characters ' ...
      '[a-zA-Z0-9]']);
  bool = false;

elseif ~iscellstr({position(:).environment}) || ...
    ~all(strcmp({position(:).environment}, ...
    regexp({position(:).environment},'[a-zA-Z0-9]*','match','once')))
  warning(['environment field must be a string containing characters ' ...
      '[a-zA-Z0-9]']);
  bool = false;

elseif ~all(cellfun(@isnumeric,{position(:).timestamp})) || ...
    ~all(cellfun(@(c) isa(c,'uint32'),{position(:).timestamp})) || ...
    ~all(cellfun(@isvector,{position(:).timestamp})) || ...
    ~all(cellfun(@(c) (size(c,2) == 1),{position(:).timestamp})) || ...
    ~all(cellfun(@(c) isreal(c),{position(:).timestamp})) || ...
    ~all(cellfun(@(c) all(diff(c) > 0),{position(:).timestamp}))
  warning(['timestamp field must be a column vector of strictly ' ...
      'monotonically increasing real uint32 timestamps']);
  bool = false;

elseif ~all(cellfun(@isnumeric,{position(:).x})) || ...
    ~all(cellfun(@(c) isa(c,'single'),{position(:).x})) || ...
    ~all(cellfun(@isvector,{position(:).x})) || ...
    ~all(cellfun(@(c) (size(c,2) == 1),{position(:).x})) || ...
    ~all(cellfun(@(c) isreal(c),{position(:).x}))
  warning('x field must be a column vector of single reals');
  bool = false;

elseif ~all(cellfun(@isnumeric,{position(:).y})) || ...
    ~all(cellfun(@(c) isa(c,'single'),{position(:).y})) || ...
    ~all(cellfun(@isvector,{position(:).y})) || ...
    ~all(cellfun(@(c) (size(c,2) == 1),{position(:).y})) || ...
    ~all(cellfun(@(c) isreal(c),{position(:).y}))
  warning('y field must be a column vector of single reals');
  bool = false;

elseif ~all(cellfun(@isnumeric,{position(:).x_velocity})) || ...
    ~all(cellfun(@(c) isa(c,'single'),{position(:).x_velocity})) || ...
    ~all(cellfun(@isvector,{position(:).x_velocity})) || ...
    ~all(cellfun(@(c) (size(c,2) == 1),{position(:).x_velocity})) || ...
    ~all(cellfun(@(c) isreal(c),{position(:).x_velocity}))
  warning('x_velocity field must be a column vector of single reals');
  bool = false;

elseif ~all(cellfun(@isnumeric,{position(:).y_velocity})) || ...
    ~all(cellfun(@(c) isa(c,'single'),{position(:).y_velocity})) || ...
    ~all(cellfun(@isvector,{position(:).y_velocity})) || ...
    ~all(cellfun(@(c) (size(c,2) == 1),{position(:).y_velocity})) || ...
    ~all(cellfun(@(c) isreal(c),{position(:).y_velocity}))
  warning('y_velocity field must be a column vector of single reals');
  bool = false;

elseif ~all(cellfun(@isnumeric,{position(:).head_direction})) || ...
    ~all(cellfun(@(c) isa(c,'single'),{position(:).head_direction})) || ...
    ~all(cellfun(@isvector,{position(:).head_direction})) || ...
    ~all(cellfun(@(c) (size(c,2) == 1),{position(:).head_direction})) || ...
    ~all(cellfun(@(c) isreal(c),{position(:).head_direction}))
  warning('head_direction field must be a column vector of single reals');
  bool = false;

elseif ~all(cellfun(@islogical,{position(:).stopped})) || ...
    ~all(cellfun(@isvector,{position(:).stopped})) || ...
    ~all(cellfun(@(c) (size(c,2) == 1),{position(:).stopped}))
  warning('stopped field must be a column vector of single reals');
  bool = false;

elseif ~all(arrayfun(@(s) isequal( ...
    size(s.timestamp),size(s.x),size(s.y), ...
    size(s.x_velocity),size(s.y_velocity),size(s.head_direction), ...
    size(s.stopped)),position))
  warning(['timestamp, x, y, x_velocity, y_velocity, head_direction, ' ...
      'stopped fields must all agree in size']);
  bool = false;

elseif ~iscellstr({position(:).units}) || ...
    ~all(cellfun(@(c) any(strcmp(c,{'cm','centimeter','centimeters'})), ...
    {position(:).units}))
  warning(['units field must be a string containing characters ' ...
      '[a-zA-Z0-9]']);
  bool = false;

else
  [i1, i2] = ndgrid(1:numel(position));
  pair_idx = find(i1 ~= i2);
  i1 = i1(pair_idx);
  i2 = i2(pair_idx);
  % Check that no two elements of position duplicate the same
  % (subject, day, epoch) 3-tuple
  if any(arrayfun(@(s1,s2) isequal( ...
      {s1.subject, s1.day, s1.epoch}, ...
      {s2.subject, s2.day, s2.epoch}),position(i1),position(i2)))
    bool = false;
  % Check that no two elements of position which share the same 
  % (subject, day) 2-tuple have overlapping timestamps
  elseif any( arrayfun(@(s1,s2) isequal( ...
      {s1.subject, s1.day},{s2.subject, s2.day}), ...
      position(i1),position(i2)) & ...
      arrayfun(@(s1,s2) ...
      ~(all(s1.timestamp < min(s2.timestamp)) || ...
      all(s1.timestamp > max(s2.timestamp))), ...
      position(i1),position(i2)) )
    bool = false;
  else
    bool = true;
  end

end

