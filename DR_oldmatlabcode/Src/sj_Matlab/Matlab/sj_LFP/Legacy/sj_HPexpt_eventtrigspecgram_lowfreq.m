function [params] = sj_HPexpt_eventtrigspecgram_lowfreq(prefix, day, epochs, tet, trigtype, riptet, do_wrtgnd, dospeed, figopt,varargin)
% Shantanu - Nov 2012. Focus on lower bands - especially for spindles
% Get and plot ripple trig spec - Zscore using output generated by sj_HPexpt_baselinespecgram
% From Kenny and Maggies - event_spectrograms .m and calcriptriggerredspectrograms.m respectively
% ADAPT TO DO Other Triggers as well

% sj_HPexpt_eventtrigspecgram_lowfreq('HPa', 2, [2 4], 15,'rip', 4, 1,[],1,'fpass',[0 100]);
% sj_HPexpt_eventtrigspecgram_lowfreq('HPb', 1, [7], 9,'spin', 9, 1,[],1,'fpass',[0 100]);
% sj_HPexpt_eventtrigspecgram_lowfreq('HPb', 1, [4 6], 9,'rip', 4, 1,[],1,'fpass',[0 100]);
% sj_HPexpt_eventtrigspecgram_lowfreq('HPb', 1, [4 6], 4,'rew', [], 1, [],1,'fpass',[0 40]);
% sj_HPexpt_eventtrigspecgram_lowfreq('HPb', 1, [4 6], 4,'norew', [], 1, [],1,'fpass',[0 40]);

if nargin<1,
    keyboard
    error('Please enter Expt Prefix and Day No!');
end
if nargin<2,
    keyboard
    error('Please enter Day No!');
end
if nargin<3,
    epochs=1; %% Epochs
end
if nargin<4,
    tet=1; %
end
if trigtype<5,
    trigtype='rip'; %
end
if nargin<6,
    riptet=4; % Have to start using getripples to look at ripples across multiple tetrodes!
end
if nargin<7,
    do_wrtgnd=1; % Whether to also do with respect to ground
end
if nargin<8,
    dospeed=0; %
end
if nargin<8,
    figopt=0; %
end
saveg1=0;


do_random = 0; % To align to random triggers



% Define Chronux params
% -------------------------------------------
win = [3 3]; % Window around triggering events / ripples. Change below acording to trigger type
movingwin = [1000 100]/1000; cwin = movingwin;
params.Fs = 1500;
params.fpass = [0 40];
%params.trialave = 0; % This is 0 by default
params.tapers = [3 5]; % Should I put this in or let it use default tapers
params.err = [2 0.05];

% Speed parameters
lowsp_thrs = 2; % cm/sec
highsp_thrs = 7; % cm/sec

% Sleep
if ismember(epochs,[1 3 5 7]),
    lowsp_thrs = 0.5; %cm/sec
    highsp_thrs = 2; % cm/sec
end


%set variable options
for option = 1:2:length(varargin)-1
    switch varargin{option}
        case 'movingwin'
            movingwin = varargin{option+1};
        case 'fpass'
            params.fpass = varargin{option+1};
    end
end

if params.fpass(2) == 400
    savetag = '';
    movingwin = [100 10]/1000; cwin = movingwin;
end
if params.fpass(2) == 100
    savetag = 'mid';
    movingwin = [400 40]/1000; cwin = movingwin;
end
if params.fpass(2) == 40
    savetag = 'low';
    movingwin = [1000 100]/1000; cwin = movingwin;
end
if params.fpass(2) == 10
    savetag = 'floor';
    movingwin = [4000 400]/1000; 
end



smwin=2; % Smoothing along frequency  and/or time axis


% SET DATA
% -------------------------------------------

switch prefix
    case 'HPa'
        rawdir = '/data25/sjadhav/HPExpt/HPa/';
        directoryname = '/data25/sjadhav/HPExpt/HPa_direct/';
    case 'HPb'
        rawdir = '/data25/sjadhav/HPExpt/HPb/';
        directoryname = '/data25/sjadhav/HPExpt/HPb_direct/';
end
dir2=directoryname;

if (day<10)
    daystring = ['0',num2str(day)];
else
    daystring = num2str(day);
end

if (tet<10)
    tetstring = ['0',num2str(tet)];
else
    tetstring = num2str(tet);
end


S_all = []; Sgnd_all = [];
Smean_all=[]; Sgndmean_all=[];

for ep=1:length(epochs)
    
    epoch = epochs(ep);
    
    
    
    switch trigtype
        case 'rip'
     
            if params.fpass(2) == 400
                win = [0.5 0.5];
            else
                win = [2 2];
            end
            
            if params.fpass(2) == 10
                win = [8 8];
            end
            
            
            % Get Ripple Times - HAVE TO SWITCH TO USING getripples FOR LOOKING ACROSS MULTIPLE TETRODES
            % -------------------------------------------------------------------------------------------
            % SHOULD SWITCH THIS TO ALLTET. If alltet does not exist, then use given tet/tets.
            ripfile = sprintf('%s/%sripples%02d.mat', directoryname, prefix, day);
            load(ripfile);
            rip_starttime=[]; rip_sizes=[];
            for i=1:length(riptet)
                currriptet=riptet(i);
                rip_starttime = [rip_starttime; ripples{day}{epoch}{currriptet}.starttime];   % in sec
                rip_sizes = [rip_sizes; ripples{day}{epoch}{currriptet}.maxthresh];   % in units of std dev
            end
            
            %rem = find((rip_sizes<3) | (rip_sizes>4)); % [HPb: Day1 Low speed - Keep all. High speed - Keep above 4.5 sds]
            rem = find(rip_sizes<4);
            rip_starttime(rem) = [];
            rip_sizes(rem) = [];
            
            [rip_starttime,sortidx] = sort(rip_starttime);
            rip_sizes = rip_sizes(sortidx);
            % Define triggering events as the start of each ripple
            triggers = rip_starttime;
            
            % Implement speed criterion
            if ~isempty(dospeed)
                posfile = sprintf('%s/%spos%02d.mat', directoryname, prefix, day);
                load(posfile);
                absvel = abs(pos{day}{epoch}.data(:,5)); % Can also use field 9
                postime = pos{day}{epoch}.data(:,1); % in secs
            
                pidx = lookup(triggers,postime);
                speed_atrip = absvel(pidx);
                lowsp_idx = find(speed_atrip <= lowsp_thrs);
                highsp_idx = find(speed_atrip >= highsp_thrs);
                
                if strcmp(dospeed,'low')==1
                    triggers = triggers(lowsp_idx);
                end
                
                if strcmp(dospeed,'high')==1
                    triggers = triggers(highsp_idx);
                end 
            end
            
            % Get random triggers 
            % Time vector from starttime to endtime, but skip firat and lst few secs (say 5 seconds)
            time_st = ripples{day}{epoch}{currriptet}.timerange(1) + 5;
            time_end = ripples{day}{epoch}{currriptet}.timerange(2) - 5;
            rip_timeax = time_st:(1/params.Fs):time_end;
            pickidx = randperm(length(rip_timeax));
            triggers_rand = rip_timeax(pickidx(1:length(triggers))); % Random events of length triggers
            %triggers_rand = rip_timeax(pickidx(1:1000)); % x random events
            clear rip_timax pickidx            
            
         case 'spin'
     
            if params.fpass(2) == 400
                win = [2 2];
            else
                win = [2 4];
            end
            
            if params.fpass(2) == 10
                win = [8 8];
            end
             
            % Get Spindle Times - HAVE TO SWITCH TO USING getripples FOR LOOKING ACROSS MULTIPLE TETRODES
            % -------------------------------------------------------------------------------------------
            % SHOULD SWITCH THIS TO ALLTET. If alltet does not exist, then use given tet/tets.
            spintet = riptet;
            spinfile = sprintf('%s/%sspindles%02d.mat', directoryname, prefix, day);
            load(spinfile);
            spin_starttime=[]; spin_sizes=[];
            for i=1:length(spintet)
                currspintet=spintet(i);
                spin_starttime = [spin_starttime; spindles{day}{epoch}{currspintet}.starttime];   % in sec
                spin_sizes = [spin_sizes; spindles{day}{epoch}{currspintet}.maxthresh];   % in units of std dev
            end
            
            %rem = find((spin_sizes<3) | (spin_sizes>4));
            rem = find(spin_sizes<3);
            spin_starttime(rem) = [];
            spin_sizes(rem) = [];
            
            [spin_starttime,sortidx] = sort(spin_starttime);
            spin_sizes = spin_sizes(sortidx);
            % Define triggering events as the start of each spinple
            triggers = spin_starttime;
            
            % Implement speed criterion
            if ~isempty(dospeed)
                posfile = sprintf('%s/%spos%02d.mat', directoryname, prefix, day);
                load(posfile);
                absvel = abs(pos{day}{epoch}.data(:,5)); % Can also use field 9
                postime = pos{day}{epoch}.data(:,1); % in secs
            
                pidx = lookup(triggers,postime);
                speed_atspin = absvel(pidx);
                lowsp_idx = find(speed_atspin <= lowsp_thrs);
                highsp_idx = find(speed_atspin >= highsp_thrs);
                
                if strcmp(dospeed,'low')==1
                    triggers = triggers(lowsp_idx);
                end
                
                if strcmp(dospeed,'high')==1
                    triggers = triggers(highsp_idx);
                end 
            end
            
            % Get random triggers 
            % Time vector from starttime to endtime, but skip firat and lst few secs (say 5 seconds)
            time_st = spindles{day}{epoch}{currspintet}.timerange(1) + 5;
            time_end = spindles{day}{epoch}{currspintet}.timerange(2) - 5;
            spin_timeax = time_st:(1/params.Fs):time_end;
            pickidx = randperm(length(spin_timeax));
            triggers_rand = spin_timeax(pickidx(1:length(triggers))); % Random events of length triggers
            %triggers_rand = spin_timeax(pickidx(1:1000)); % x random events
            clear spin_timax pickidx            
            
        case 'rew'
            
            % Load reward file
            % ---------------------------------
            rewfile = sprintf('%s/%srewardinfo%02d.mat', directoryname, prefix, day);
            load(rewfile);
            currrewinfo = rewardinfo{day}{epoch};
            useidx=2;
            currrewinfo(:,2) = currrewinfo(:,2)./10000; % secs
            allrewidx = find(currrewinfo(:,3)==1); allrewtime = currrewinfo(allrewidx,useidx);
            triggers = allrewtime;
            
        case 'norew'
            
            % Load reward file
            % ---------------------------------
            rewfile = sprintf('%s/%srewardinfo%02d.mat', directoryname, prefix, day);
            load(rewfile);
            currrewinfo = rewardinfo{day}{epoch};
            useidx=2;
            currrewinfo(:,2) = currrewinfo(:,2)./10000; % secs
            allnorewidx = find(currrewinfo(:,3)==0); allnorewtime = currrewinfo(allnorewidx,useidx);
            triggers = allnorewtime;
            
    end % end switch
    
    
    
    % Get the Baseline Spectrogram values
    % -----------------------------------
    cd([directoryname,'/EEGSpec/']);
    eegspecfile = [dir2,'/EEGSpec/',prefix,'eegspec',savetag,daystring,'-Tet',tetstring];
    load(eegspecfile);
    % Data
    %spec = eegspec{day}{epoch}{tet}.specgram;
    meanspec = eegspec{day}{epoch}{tet}.meanspec;
    stdspec = eegspec{day}{epoch}{tet}.stdspec;
    % Mean and std for whole day
    %lastepoch = length(eegspec{day});
    meandayspec = eegspec{day}{1}{tet}.meandayspec; % Stored in first epoch
    stddayspec = eegspec{day}{1}{tet}.stddayspec;
    %clear spec
    
    % Now get EEG for the given tet and process
    % --------------------------------------
    
    cd([directoryname,'/EEG/']);
    curreegfile = [dir2,'/EEG/',prefix,'eeg',daystring,'-',num2str(epoch),'-',tetstring];
    load(curreegfile);
    lfp = eeg{day}{epoch}{tet}.data;
    starttime = eeg{day}{epoch}{tet}.starttime; % This is in secs
    endtime = starttime + (length(lfp)-1) * (1 / params.Fs);
    clear eeg
    
    % Update triggers
    % -----------------
    % Subtract startime of epoch to get this with start at 0.
    % You only input eeg vector to mtspecgram, which starts at index 1

    triggers = triggers-starttime; endtime = endtime - starttime;
    if do_random ==1, triggers_rand = triggers_rand-starttime; end
    
    %Remove triggering events that are too close to the beginning or end
    while triggers(1)<win(1)
        triggers(1) = [];
    end    
    rem = find(triggers + win(2) > endtime);
    triggers(rem) = [];
%     while triggers(end)> endtime-win(2)
%         triggers(end) = [];
%     end
%     triggers(end)=[];
    
    % Calculate event triggered spectrogram
    % -----------------------------------
    disp(['Doing event-triggered specgram. Ntriggers = ',num2str(length(triggers))]);
    [S,Stime,Sfreq] = mtspecgramtrigc(lfp,triggers,[win(1) win(2)],[cwin(1) cwin(2)],params);
    Stime = Stime - win(1); % This will make time start -win(1) instead of 0
    % Alternatively
    %--------------
    % Can cut eeg in windows around triggers and build up a matrix, and then do specgram for
    % each cut piece separately. See event_spectrogram.m from kkay for an example
    if do_random==1
        [S_rand] = mtspecgramtrigc(lfp,triggers_rand,[win(1) win(2)],[cwin(1) cwin(2)],params);
    end
    clear lfp    
    
    
    % Z-score the event-triggered  spectrogram using data from continuous spectrogram
    % ------------------------------------------------------------------------------
    S = bsxfun(@minus,S,meanspec); % Can use meandayspec and stddayspec instead
    S = bsxfun(@rdivide,S,stdspec);
    Smean = mean(S,3); % mean across events
    %S_all = [S_all;S];  
    Smean_all(:,:,ep) = Smean;
    if do_random==1
        S_rand = bsxfun(@minus,S_rand,meanspec(1:size(S,2))); S_rand = bsxfun(@rdivide,S_rand,stdspec(1:size(S,2)));
        Smean_rand = mean(S_rand,3);
        %S_all = [S_all;S];
        Smean_all_rand(:,:,ep) = Smean_rand;
    end
    
    % Alternative way
    % for i = 1:size(S,1)
    %     for j = 1:size(S,3)
    %     	S(i,:,j) = (S(i,:,j) - meanspec)./stdspec;
    %     end
    % end
    
    % Do EEG wrt Gnd if asked for
    % ---------------------------
    gndflag=0;
    if do_wrtgnd==1
        eeggndspecfile = [dir2,'/EEGSpec/',prefix,'eeggndspec',savetag,daystring,'-Tet',tetstring];
        if (exist([eeggndspecfile,'.mat'],'file'))~=2
            disp(['EEG wrt Gnd file seems to not exist']);
            gndflag=0;
        else
            gndflag=1;
            load(eeggndspecfile);
            % Data
            %spec = eeggndspec{day}{epoch}{tet}.specgram;
            meanspecgnd = eeggndspec{day}{epoch}{tet}.meanspec;
            stdspecgnd = eeggndspec{day}{epoch}{tet}.stdspec;
            % Mean and std for whole day
            %lastepoch = length(eegspec{day});
            meandayspecgnd = eeggndspec{day}{1}{tet}.meandayspec; % Stored in first epoch
            stddayspecgnd = eeggndspec{day}{1}{tet}.stddayspec;
            %clear spec
            
            % Specgram the event-triggered EEG
            curreeggndfile = [dir2,'/EEG/',prefix,'eeggnd',daystring,'-',num2str(epoch),'-',tetstring];
            load(curreeggndfile);
            lfpgnd = eeggnd{day}{epoch}{tet}.data;
            disp(['Doing event-triggered specgram for eeg wrt gnd']);
            [Sgnd] = mtspecgramtrigc(lfpgnd,triggers,[win(1) win(2)],[cwin(1) cwin(2)],params);
            if do_random==1
                [Sgnd_rand] = mtspecgramtrigc(lfpgnd,triggers_rand,[win(1) win(2)],[cwin(1) cwin(2)],params);
            end
            clear lfpgnd
            
            % Z-score
            Sgnd = bsxfun(@minus,Sgnd,meanspecgnd(1:size(S,2))); % Can use meandayspec and stddayspec instead
            Sgnd = bsxfun(@rdivide,Sgnd,stdspecgnd(1:size(S,2)));
            Sgndmean = mean(Sgnd,3);
            
            %Sgnd_all = [Sgnd_all;Sgnd];
            Sgndmean_all(:,:,ep) = Sgndmean;
            if do_random==1
                Sgnd_rand = bsxfun(@minus,Sgnd_rand,meanspecgnd(1:size(S,2))); Sgnd_rand = bsxfun(@rdivide,Sgnd_rand,stdspecgnd(1:size(S,2)));
                Sgndmean_rand = mean(Sgnd_rand,3);
                %S_all = [S_all;S];
                Sgndmean_all_rand(:,:,ep) = Sgndmean_rand;
            end
            
            
        end
    end
    
end % end epochs

if length(epochs) > 1
    Smean = mean(Smean_all,3); % Mean across epochs
    if gndflag==1
        Sgndmean = mean(Sgndmean_all,3); % Mean across epochs
    end
    if do_random==1
        Smean_rand = mean(Smean_all_rand,3); % Mean across epochs
        if gndflag==1
            Sgndmean_rand = mean(Sgndmean_all_rand,3); % Mean across epochs
        end
    end
end


% %SMOOTHING
% %----------
%if strcmp(trigtype,'spin')
if params.fpass(2) ~= 400
    % Smoothing along freq axis
    for i=1:size(Smean,2)
        winst = i-smwin/2; winend = i+smwin/2;
        if winst<1, winst=1; end
        if winend>size(Smean,2), winend = size(Smean,2); end
        Smean(:,i) = mean(Smean(:,winst:winend),2);
        if gndflag==1
            Sgndmean(:,i) = mean(Sgndmean(:,winst:winend),2);
        end
    end
    
    % Smoothing along time axis
    for i=1:size(Smean,1)
        winst = i-smwin/2; winend = i+smwin/2;
        if winst<1, winst=1; end
        if winend>size(Smean,1), winend = size(Smean,1); end
        Smean(i,:) = mean(Smean(winst:winend,:),1);
        if gndflag==1
            Sgndmean(i,:) = mean(Sgndmean(winst:winend,:),1);
        end
    end
end




%% ------------------------------------------------
% PLOT
% -------------------------------------------------

if figopt ==1
    
    % ------------------------------
    % Figure and Font Sizes
    forppr = 1;
    % If yes, everything set to redimscreen_figforppr1
    % If not, everything set to redimscreen_figforppt1
    
    figdir = '/data25/sjadhav/';
    %figdir = '/data25/sjadhav/RippleInterruption/Figures/01AugSep11_RippleDisFigs/DisruptnCalibrationAndEgs/CalibrationEgs/';
    datadir = '/data25/sjadhav/';
    summdir = figdir;
    
    set(0,'defaultaxesfontweight','normal'); set(0,'defaultaxeslinewidth',2);
    if forppr==1
        set(0,'defaultaxesfontsize',16);
        tfont = 18; % title font
        xfont = 16;
        yfont = 16;
    else
        set(0,'defaultaxesfontsize',24);
        tfont = 28;
        xfont = 20;
        yfont = 20;
    end
    clr = {'b','r','g','c','m','y','k','r'};
    % ---------------------------------------
    
    
    
    %% Specgram EEG
    % -------------
    
    figure; hold on;
    set(gcf,'Position',[55 660 560 420]);
    imagesc(Stime,Sfreq,Smean'); colorbar;
    title(['Tet ',num2str(tet),' Specgram aligned to ',trigtype],'FontSize',18,'Fontweight','normal');
    ylabel('Freq','FontSize',20,'Fontweight','normal');
    xlabel('Time(s)','FontSize',20,'Fontweight','normal');
    set(gca,'XLim',[min(Stime) max(Stime)]);
    set(gca,'YLim',[min(Sfreq) max(Sfreq)]);
    
    % Plot Line at 0 ms - Start of ripple
    ypts = Sfreq;
    xpts = 0*ones(size(ypts));
    plot(xpts , ypts, 'k--','Linewidth',3);
    
    % Plot lines at 100ms
    xpts = (100)*ones(size(ypts));
    plot(xpts , ypts, 'k--','Linewidth',2);
    
    if saveg1==1,
        figfile = [figdir,prefix,'_Day',num2str(day),'_Tet',num2str(tetu),'_HpCellMatrix'];
        print('-dpdf', figfile);
        print('-djpeg', figfile);
        saveas(gcf,figfile,'fig');
    end
    
    %% Specgram EEG Gnd
    % ------------------
    
    if gndflag==1
        figure; hold on;
        set(gcf,'Position',[820 660 560 420])
        imagesc(Stime,Sfreq,Sgndmean'); colorbar; % USE SAME COLOR SCALE AS REAL-TRIGGER GRAPH
        title(['Tet ',num2str(tet),' Specgram wrt GND aligned to ', trigtype],'FontSize',18,'Fontweight','normal');
        ylabel('Freq','FontSize',20,'Fontweight','normal');
        xlabel('Time(s)','FontSize',20,'Fontweight','normal');
        set(gca,'XLim',[min(Stime) max(Stime)]);
        set(gca,'YLim',[min(Sfreq) max(Sfreq)]);
        
        % Plot Line at 0 ms - Start of ripple
        ypts = Sfreq;
        xpts = 0*ones(size(ypts));
        plot(xpts , ypts, 'k--','Linewidth',3);
        
        % Plot lines at 100ms
        xpts = (100)*ones(size(ypts));
        plot(xpts , ypts, 'k--','Linewidth',2);
        
        if saveg1==1,
            figfile = [figdir,prefix,'_Day',num2str(day),'_Tet',num2str(tetu),'_HpCellMatrix'];
            print('-dpdf', figfile);
            print('-djpeg', figfile);
            saveas(gcf,figfile,'fig');
        end
    end
    
    if do_random==1
        
        %% Specgram EEG Random
        % -----------------------
        
        figure; hold on;
        set(gcf,'Position',[55 140 560 420]);
        imagesc(Stime,Sfreq,Smean_rand',[min(Smean(:)) max(Smean(:))]); colorbar; % USE SAME COLOR SCALE AS REAL-TRIGGER GRAPH
        title(['Tet ',num2str(tet),' Specgram aligned to random events'],'FontSize',18,'Fontweight','normal');
        ylabel('Freq','FontSize',20,'Fontweight','normal');
        xlabel('Time(s)','FontSize',20,'Fontweight','normal');
        set(gca,'XLim',[min(Stime) max(Stime)]);
        set(gca,'YLim',[min(Sfreq) max(Sfreq)]);
        % Plot Line at 0 ms - Start of ripple
        ypts = Sfreq;
        xpts = 0*ones(size(ypts));
        plot(xpts , ypts, 'k--','Linewidth',3);
        % Plot lines at 100ms
        xpts = (100)*ones(size(ypts));
        plot(xpts , ypts, 'k--','Linewidth',2);
        if saveg1==1,
            figfile = [figdir,prefix,'_Day',num2str(day),'_Tet',num2str(tetu),'_HpCellMatrix'];
            print('-dpdf', figfile);
            print('-djpeg', figfile);
            saveas(gcf,figfile,'fig');
        end
        
        %% Specgram EEG Gnd Random
        % -----------------------
        
        if gndflag==1
            figure; hold on;
            set(gcf,'Position',[820 140 560 420]);
            imagesc(Stime,Sfreq,Sgndmean_rand',[min(Sgndmean(:)) max(Sgndmean(:))]); colorbar;
            title(['Tet ',num2str(tet),' Specgram GND aligned to random events'],'FontSize',18,'Fontweight','normal');
            ylabel('Freq','FontSize',20,'Fontweight','normal');
            xlabel('Time(s)','FontSize',20,'Fontweight','normal');
            set(gca,'XLim',[min(Stime) max(Stime)]);
            set(gca,'YLim',[min(Sfreq) max(Sfreq)]);
            % Plot Line at 0 ms - Start of ripple
            ypts = Sfreq;
            xpts = 0*ones(size(ypts));
            plot(xpts , ypts, 'k--','Linewidth',3);
            % Plot lines at 100ms
            xpts = (100)*ones(size(ypts));
            plot(xpts , ypts, 'k--','Linewidth',2);
            if saveg1==1,
                figfile = [figdir,prefix,'_Day',num2str(day),'_Tet',num2str(tetu),'_HpCellMatrix'];
                print('-dpdf', figfile);
                print('-djpeg', figfile);
                saveas(gcf,figfile,'fig');
            end
        end
        
    end % end do_random
    
    
end % end figopt

i=1;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



