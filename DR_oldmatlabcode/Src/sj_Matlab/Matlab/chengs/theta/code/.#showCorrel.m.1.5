function showCorrel(pairsel, spsel, scaling)
%function showCorrel
%  Show correlations between cells with overlapping placefields

plotall= 0;
rerun=1;
%pairsel= 'overlap';  % 'none', 'overlap', 'all'
%spsel= 'non_run';   % spike selection {'all', 'traj', 'sat', 'traj_sat', 'run'}
%                 'traj_sat2', 'placefield', 'ripple', 'non_run'
%scaling= 'coef';
dt= 0.002;      % [sec] timestep
T= 0.25;         % [sec] +/- width of CCG window
cutfreq= 40;    % cutoff frequency [Hz] 

sel{1}.selectid= 'pf5-fam';
sel{1}.label= 'fam';

sel{2}.selectid= 'pf5-novelArm';
sel{2}.novelDay= 1;
sel{2}.label= 'day-1';

sel{3}.selectid= 'pf5-novelArm';
sel{3}.novelDay= 2;
sel{3}.label= 'day-2';

sel{4}.selectid= 'pf5-novelArm';
sel{4}.novelDay= 3;
sel{4}.label= 'day-3';

scale= 0; pairs= 1;
if strcmp(scaling, 'coef'); scale=1 ; end
if strcmp(pairsel, 'none'); pairs=0 ; end

M= ceil(T/dt);
lags= [-M:M];
nsel=length(sel);
xc= zeros(2*M+1, 1);
savedir= pwd;
setRoot;
cd(sprintf('%s/work/CCG', root));
ensuredir(pairsel);
cd(pairsel);
ensuredir(spsel);
cd(spsel);

setRoot;
if(rerun)
    for isel=1:nsel
        selectid= sel{isel}.selectid;
        fprintf(1, 'Calculating %s, %s (spike select= ''%s'')...\n', ...
            selectid, sel{isel}.label, spsel);
        novelDay= 0;
        if isfield(sel{isel}, 'novelDay')
            novelDay= sel{isel}.novelDay;
        end
        [cl, nc]= collectCellList(selectid);
        if(pairs) 
            [pl, np]= collectPairs(cl, pairsel);
        else
            pl= cl; np= nc;
        end
        pairlist{isel}= pl; 

        oldrat= ''; oldd= -1; ix= 0; 
        for ip=1:np
            if novelDay & pl.day(ip)~=novelDay; continue; end

            % load spike times of 1st cell
            rat= pl.rat{ip};
            num= pl.cellnum(ip,:); d=num(1); e=num(2); tet=num(3); c=num(4);
            if ~strcmp(rat, oldrat) | oldd~= d
                oldrat= rat; oldd= d;
                load(sprintf('%s/%s/data2/spikedata%.2d.mat', root, rat, d));
                load(sprintf('%s/%s/data2/behavdata%.2d.mat', root, rat, d));
            end
            sd{1}= spikedata{d}{e}{tet}{c};

            if(pairs)
                % load spike times of 2nd cell
                num2= pl.cellnum(ip,5:8); 
                d=num2(1); e=num2(2); tet=num2(3); c=num2(4);
                sd{2}= spikedata{d}{e}{tet}{c};
            end

            [t, rej]= auxSelectSpikes(sd, behavdata{d}{e}, spsel, pl, ip);
            if(rej) continue; end

            ix= ix+1;
            xc= spikeCCG(t, M, dt, scale);

            XC{isel}(:,ix)= xc;
            IX{isel}(ix)= ip;
            
            fprintf(1, '  %3d/%3d\n', ix, np);
        end
        NP(isel)= ix;
    end
    clear rerun xc
    clear behavdata spikedata tm novelDay selectid time s1 s2
    clear rat oldrat day oldd d e c tet  nC iC ipnapris np
    clear mint maxt num num2 sp1 sp2 
    save(sprintf('XC_%s_%dms', scaling, 1000*dt));
else
    load(sprintf('XC_%s_%dms', scaling, 1000*dt));
end

fprintf(1, 'Analyzing pairs=''%s'', spikes=''%s'', scaling=''%s'', dt= %dms, T= %ds\n', pairsel, spsel, scaling, round(dt*1000), round(T*1000));

B= fir1(4, cutfreq*2*dt);
for is=1:nsel
    FXC{is}= filtfilt(B, 1, XC{is});
end

% find maximum correlation
maxy= 0; mXC= {};
for is=1:nsel
    mXC{is}= max(FXC{is});
    maxy= max([maxy, mXC{is}]);
end
auxCmpDist(mXC, sel, 'MaxCorr');
auxPlotCDF(mXC, sel, 'MaxCorr', scaling)
title([pairsel '-' spsel])

% ratio of center peak to average of side peaks
pr= auxCalcPeakRatios(FXC, dt, lags);
auxCmpDist(pr, sel, 'PeakRatio');
auxPlotCDF(pr, sel, 'PeakRatio', scaling)
title([pairsel '-' spsel])
%auxHist(pr, sel, 'PeakRatio', scaling)
%auxCut(pr, sel, 2, 'PeakRatio')

% index of center peak to side peaks
%pi= auxCalcPeakIndex(XC, dt, lags);
%auxCmpDist(pi, sel, 'PeakIndex');
%auxPlotCDF(pi, sel, 'PeakIndex', scaling)
%auxHist(pi, sel, 'PeakIndex', scaling)

% location of center peak 
%lp= auxCalcPeakLoc(FXC, dt, lags);
%auxCmpDist(lp, sel, 'PeakLoc');
%auxPlotCDF(lp, sel, 'PeakLoc', scaling)

% max of power spectrum
%[m,f]= auxCalcPSMax(XC, dt, lags);
%auxHist(f, sel, 'MaxFreq', scaling)
%auxCmpDist(m, sel, 'MaxPower');
%auxPlotCDF(m, sel, 'MaxPower', scaling)

%m= auxCalcPS(XC, dt, lags);
%auxCmpDist(m, sel, 'Power');
%auxPlotCDF(m, sel, 'Power', scaling)

% plot all CCG
if(plotall)
    auxPlotCCG(FXC, dt, lags, sel, pairlist, IX);
end


%keyboard

cd(savedir)

function [t,rej]= auxSelectSpikes(sd, be, spsel, pl, ip)
burstdiff= 0.020;
rej= 0; t= {};
if strfind(spsel, 'traj') 
    if ~isfield(spsel{1}, 'traj')
        error('requested traj selection but traj was not given');
    end
    trajs= pl.traj{ip};
end
for i=1:length(sd)
    % select only spikes on traj and on satellite arms
    switch spsel
    case 'sat'
        spind= find(75<sd{i}.linpos & sd{i}.linpos < 150);
    case 'traj_end'
        spind= find(ismember(be.traj(sd{i}.index),trajs) & sd{i}.linpos>75);
    case {'traj_sat', 'traj_sat2'}
        spind= find(ismember(be.traj(sd{i}.index),trajs) & 75<sd{i}.linpos & sd{i}.linpos < 150);
    case {'traj_nosat'}
        spind= find(ismember(be.traj(sd{i}.index),trajs) & (sd{i}.linpos<75 | sd{i}.linpos>150));
    case 'traj'
        spind= find(ismember(be.traj(sd{i}.index),trajs));
    case 'run'
        spind= find(be.traj(sd{i}.index)>=0);
    case 'non_run'
        spind= find(be.traj(sd{i}.index)<0);
    case {'ripple', 'non_ripple', 'non_ripple_non_run'}
        % extend ripple event by +/- n*2ms
        ndata= length(be.ripple);
        tmpind= find(be.ripple);
        n= 200;
        ind= zeros(length(tmpind), 2*n+1);
        for j=-n:n
            ind(:,j+n+1)= tmpind+j;
        end
        ind(ind<1)= 1; ind(ind>ndata)= ndata;
        ind= unique(ind);

        be.ripple(ind)=1;
%        keyboard

        if strcmp(spsel, 'ripple')
            spind= find(be.ripple(sd{i}.index));
        elseif strfind(spsel, 'non_run')
            spind= find(~be.ripple(sd{i}.index)& be.traj(sd{i}.index)<0);
        else
            spind= find(~be.ripple(sd{i}.index));
        end
    case {'run_sat', 'run_sat_burst'}
        spind= find(75<sd{i}.linpos & sd{i}.linpos < 150 & be.traj(sd{i}.index)>=0);
    case {'all', 'all_burst'}
        spind= 1:length(sd{i}.index);
    case 'placefield'
        x= be.linpos(sd{i}.index);
        npf= size(pl.pf{ip}, 2);
        spind= [];
        for ipf=1:npf
            minx= min(pl.pf{ip}(:,ipf)); maxx= max(pl.pf{ip}(:,ipf));
            tmp= find(be.traj(sd{i}.index)==pl.traj{ip}(ipf) & minx<x & x<maxx);
            spind= [spind; tmp];
        end
        spind= sort(spind);
    otherwise
        error(['Unknown spike selection filter "' spsel '".']);
    end

    % check number of spikes in selection
    switch spsel
    case 'placefield'
        if length(spind)<20; rej=1;  return; end
    case 'traj_sat2'
        if length(spind)<100; rej=1;  return; end
    case 'traj_nosat'
        if length(spind)<10; rej=1;  return; end
    case 'ripple'
        if length(spind)<10; rej=1;  return; end
    otherwise
        if length(spind)<100; 
            warning(sprintf('Reject pair with only  %d spikes!',length(spind))); 
            rej=1;
        end
    end
    t{i}= sd{i}.time(spind);
    if strfind(spsel, 'burst')
        d= diff(t{i});
        ind= find(d>burstdiff);
        t{i}= [t{i}(1);t{i}(ind+1)];
    end
end

function auxCmpDist(x, sel, var, alpha)
if nargin<4; alpha= 0.05; end
fprintf(1, '\ncomparing %s\n', var);
nsel= length(x);
for is=2:nsel
    p= ranksum(x{1}, x{is}, alpha);
    fprintf(1, 'Ranksum test %s vs. %s p=%.3f.\n', sel{1}.label, sel{is}.label, p);
    [h,p]= kstest2(x{1}, x{is}, alpha);
    fprintf(1, 'KS test %s vs. %s p=%.3f.\n', sel{1}.label, sel{is}.label, p);
end

function auxHist(x, sel, var, outname)
nsel= length(x);
minx=1e10; maxx= -1e10;
for is=1:nsel; maxx= max([x{is}, maxx]); minx= min([x{is}, minx]); end
b= linspace(minx, maxx, 11);
lstr= {};
for is=1:nsel
    h(:,is)= histc(x{is}', b);
    h(:,is)= h(:,is)/sum(h(:,is));
    lstr{is}= sel{is}.label;
end
figure
%plot(b(1:end-1)+(b(2)-b(1))/2, h(1:end-1,:));
bar(b+(b(2)-b(1))/2,h);
legend(lstr);
xlabel(var);
myprint('large', ['hist_' var '_' outname]);

function auxPlotCDF(x, sel, var, outname)
figure
plotcol= {'k', 'r', 'b', 'g'};
lstr= {};
nsel= length(x);
for is=1:nsel
    h= cdfplot(x{is});
    set(h, 'Color', plotcol{is});
    lstr{is}= sel{is}.label;
    hold on
end
legend(lstr);
xlabel(var);
ylabel('cdf');
title('');
myprint('large', ['cdf_' var '_' outname]);

function lp= auxCalcPeakLoc(x, dt, lags)
M= (length(lags)-1)/2;
nsel= length(x);
for is=1:nsel
    np= size(x{is}, 2);
    for ip=1:np
        % find peaks
        ipeaks= findpeaks(x{is}(:,ip)');
        i= min(abs(ipeaks-M-1));
        lp{is}(ip)= i*dt;
    end
end
%keyboard

function pr= auxCalcPeakRatios(x, dt, lags)
M= (length(lags)-1)/2;
% interval of preceding, central, and following theta cycle
tb=[-.1875, -.0625, .0625, .1875];
ti= floor(tb/dt)+M+1;
for j=1:3
    ind{j}= [ti(j):ti(j+1)];
end
nsel= length(x);
for is=1:nsel
    np= size(x{is}, 2);
    for ip=1:np
        % find peaks
        for j=1:3
            [m(j), l(j)]= max(x{is}(ind{j},ip));
        end
        if m(1)+m(3)==0
            pr{is}(ip)= 4;
        else
            pr{is}(ip)= 2*m(2)/(m(1)+m(3));
        end
    end
end

function pr= auxCalcPeakIndex(x, dt, lags)
M= (length(lags)-1)/2;
% interval of preceding, central, and following theta cycle
tb=[-.1875, -.0625, .0625, .1875];
ti= floor(tb/dt)+M+1;
for j=1:3
    ind{j}= [ti(j):ti(j+1)];
end
nsel= length(x);
for is=1:nsel
    np= size(x{is}, 2);
    for ip=1:np
        % find peaks
        for j=1:3
            [m(j), l(j)]= max(x{is}(ind{j},ip));
        end
        av= (m(1)+m(3))/2;
        pr{is}(ip)= (m(2)-av)/(m(2)+av);
    end
end

function auxCut(x, sel, cut, var)
nsel= length(x);
n= zeros(nsel, 2);
frac= zeros(nsel, 2);
for is=1:nsel
    n(is,1)= sum(x{is}<cut);
    n(is,2)= sum(x{is}>cut);
    frac(is,:)= n(is,:)/sum(n(is,:));
end
frac

% bootstrap analysis
reps= 10000;
ref= 1;
n1= length(x{ref});
f1= zeros(reps, 2);
for r=1:reps
    ind= floor(n1*rand(n1,1))+1;
    xb= x{ref}(ind);
    tmp(1)= sum(xb<cut);
    tmp(2)= sum(xb>=cut);
    f1(r,:)= tmp/n1;
end

for is=1:nsel
    p= sum(f1(:,2)>= frac(is,2))/reps;
    fprintf(1, 'bootstrap test %s vs. %s p=%.3f.\n', sel{1}.label, sel{is}.label, p);
end

function auxPlotCCG(xc, dt, lags, sel, pl, IX)
figure
nsel= length(xc);
T= lags(end)*dt;

for is=1:nsel
    np= size(xc{is},2);
    for ix=1:np
        ip= IX{is}(ix);

%        if ~((is==1 & ip==12) | (is==2 & ip==5)); continue; end
        plot(dt*lags, xc{is}(:,ix));
        set(gca, 'XLim', [-T, T]);
        num= pl{is}.cellnum(ip,:);
        tstr= sprintf('%s: %d %d %d %d', pl{is}.rat{ip}, num(1:4));
        if(length(num)>4)
            tstr= sprintf('%s, %d %d', tstr, num(7:8));
        end
        if isfield(pl{is}, 'traj')
            tstr= [tstr '; traj '];
            trajs=  pl{is}.traj{ip};
            for itraj=1:length(trajs)
                tstr= sprintf('%s %d', tstr, trajs(itraj));
            end
        end
        title(tstr);
        xlabel('time lag (sec)');
        ylabel('cross correl');
        myprint('large', sprintf('CCG-%s-%d', sel{is}.label, ip));
    end
end

function [m,f]= auxCalcPSMax(x, dt, lags)
nsel= length(x);
for is=1:nsel
    np= size(x{is}, 2);
    for ip=1:np
        [Px,freq] = pwelch(x{is}(:,ip),[],[],[],1/dt);
        % find peaks
        i= findpeaks(Px');
        [tmp, imin]= min(abs(freq(i)-8));
        m{is}(ip)= Px(i(imin));
        f{is}(ip)= freq(i(imin));
    end
end

function m= auxCalcPS(x, dt, lags)
nsel= length(x);
for is=1:nsel
    np= size(x{is}, 2);
    for ip=1:np
        [Px,freq] = pwelch(x{is}(:,ip),[],[],[],1/dt);
%figure
%        hold off
%        semilogy(freq, Px);
%        i= findpeaks(Px');
%        hold on
%        semilogy(freq(i), Px(i), '.');
%        pause
        m{is}(ip)= sum(Px(10:13));
    end
end

