%function showCorrel(selectid, pairsel) 
%function showCorrel(pairsel, spsel) 
function showCorrel
%  Show correlations between cells with overlapping placefields

plotall= 0;
pairsel= 'overlap';  % 'none', 'overlap', 'all'
spsel= 'placefield';   % spike selection {'all', 'traj', 'sat', 'traj_sat', 'run'}
%                 'traj_sat2', 'placefield', 'ripple', 'non_run'
opt.scaling= 'coef';
opt.dt= 0.002;      % [sec] timestep
opt.T= 2;         % [sec] +/- width of CCG window
opt.cutfreq= 40;    % cutoff frequency [Hz] 
opt.minspikes= 40;  % minimum number of spikes to include
opt.ref= 1;


id= 'pf10';
opt.id= id;

sel{1}.selectid= [id '-fam'];
sel{1}.pairsel= pairsel;
sel{1}.spsel= spsel;
sel{1}.label= 'fam';


%sel{2}.selectid= [id '-famArm'];
%sel{2}.pairsel= pairsel;
%sel{2}.spsel= spsel;
sel{2}.novelDay= 1;
sel{2}.label= 'fam-1';
%sel{2}.label= 'famArm';

sel{3}.selectid= [id '-famArm'];
sel{3}.pairsel= pairsel;
sel{3}.spsel= spsel;
sel{3}.novelDay= 2;
sel{3}.label= 'fam-2';

sel{4}.selectid= [id '-famArm'];
sel{4}.pairsel= pairsel;
sel{4}.spsel= spsel;
sel{4}.novelDay= 3;
sel{4}.label= 'fam-3';

sel{5}.selectid= [id '-novelArm'];
sel{5}.pairsel= pairsel;
sel{5}.spsel= spsel;
sel{5}.novelDay= 1;
sel{5}.label= 'novel-1';

sel{6}.selectid= [id '-novelArm'];
sel{6}.pairsel= pairsel;
sel{6}.spsel= spsel;
sel{6}.novelDay= 2;
sel{6}.label= 'novel-2';

sel{7}.selectid= [id '-novelArm'];
sel{7}.pairsel= pairsel;
sel{7}.spsel= spsel;
sel{7}.novelDay= 3;
sel{7}.label= 'novel-3';


newsel= {}; nS= 0;
for is=1:length(sel)
    if ~isempty(sel{is}); nS= nS+1; newsel{nS}= sel{is}; end
end
sel= newsel;

setRoot;
olddir= pwd;
%cd([root '/work']);
opt.root= root;
nsel=length(sel);

for is=1:nsel
    [XC{is}, AUX{is}]= auxGetCCG(sel{is}, opt);
end

%fprintf(1, 'Analyzing pairs=''%s'', spikes=''%s'', scaling=''%s'', dt= %dms, T=
%ds\n', pairsel, spsel, opt. scaling, round(dt*1000), round(T*1000));

load /home/chengs/theta/work/ccg_filter
B= ccg_filter.tf.num;
A= ccg_filter.tf.den;
%B= fir1(4, opt.cutfreq*2*opt.dt);
%A= 1;
for is=1:nsel
    FXC{is}= filtfilt(B, A, XC{is});
    fprintf(1, 'number of pairs %s: %d used, %d rejected (%d total)\n', ...
            sel{is}.label, AUX{is}.npairs-AUX{is}.nrej, AUX{is}.nrej, AUX{is}.npairs);
%    DT= AUX{is}.lags*opt.dt;
%    ind= find(DT>=-.070 & DT<=.070);
%    FXC{is}= FXC{is}(ind,:);
end

%keyboard
%freqz(B,A,100,1/opt.dt);

if(0)
% find maximum correlation
maxy= 0; mXC= {};
for is=1:nsel
    DT= AUX{is}.lags*opt.dt;
    ind= find(DT>=-.070 & DT<=.070);
%    ind=[1:length(AUX{is}.lags)];
    mtmax= max(FXC{is}(ind,:))';
    maxy= max([maxy; mtmax]);
    mtmin= min(FXC{is}(ind,:))';
%    mXC{is}= mtmin;
    mXC{is}= mtmax;
%    mXC{is}= (mtmax-mtmin);
     ind= mtmax>1e-6;
    mXC{is}= (mtmax(ind)-mtmin(ind))./mtmax(ind);
%    mXC{is}= (mtmax(ind)-mtmin(ind))./(mtmax(ind)+mtmin(ind));
%    mXC{is}= (mtmax-mtmin)./mtmax;
%    mXC{is}= mtmin(ind);
end
%for is=1:nsel
%    mean(mXC{is})
%end
auxCmpDist(mXC, sel, 'height central peak', opt);
auxPlotCDF(mXC, sel, 'height central peak', opt.scaling)
%title([pairsel '-' spsel])
%set(gcf, 'Name', [pairsel '-' spsel])
end

% area under CCG
%area= auxCalcCCGArea(FXC, opt, AUX);
%auxCmpDist(area, sel, 'area', opt);
%auxPlotCDF(area, sel, 'area', '')

% regression slope 
%rs= auxCalcRegSlope(FXC, opt, AUX);
%for is=1:nsel
%    tmp= auxGetDistancePF(AUX{is}.pairlist, opt);
%    tmp= auxGetOverlapPF(AUX{is}.pairlist, opt);
%    tmp= tmp(AUX{is}.ix);
%    ind= find(tmp<15);
%    rs2{is}= rs{is}(ind);
%end
%auxCmpDist(rs, sel, 'slope', opt);
%auxPlotCDF(rs, sel, 'slope', '')
%keyboard

if(1)


% calculated distance between placefields
global lp dPF
dPF= {};
for is=1:nsel
    tmp= auxGetDistancePF(AUX{is}.pairlist, opt);
    dPF{is}= tmp(AUX{is}.ix);
end
%auxCmpDist(dPF, sel, 'distance', opt);
%auxPlotCDF(dPF, sel, 'distance', opt.scaling)

% location of center peak 
[lp]= auxCalcPeakLoc(FXC, opt, AUX, dPF);
[lp, dPF]= auxCalcPeakLoc(FXC, opt, AUX, dPF);
%auxCmpDist(lp, sel, 'PeakLoc', opt);
%auxPlotCDF(lp, sel, 'PeakLoc', '')
%auxHist(lp, sel, 'PeakLoc', '')

for is=1:nsel
    ind= find(isfinite(lp{is}));
    dPF2{is}= dPF{is}(ind);
    lp2{is}= lp{is}(ind);
end

opt.xvar= 'distance';
opt.xstr= 'COM distance (cm)';
%opt.xstr= 'centroid distance (ms)';

%opt.yvar= 'CCGmax';
%opt.ystr= 'max. correlation';
%auxPlotTwoVar(dPF, mXC, opt)

opt.yvar= 'PeakSep';
opt.ystr= 'CCG peak (ms)';
auxPlotTwoVar(dPF2, lp2, opt, sel)

% firing asymmetry
%asym= auxCalcAsym(XC, opt, AUX);
%opt.yvar= 'Asym';
%opt.ystr= 'firing asym.';
%auxPlotTwoVar(dPF, asym, opt)

%for is=1:nsel
%    ind= find(dPF{is}<0 & isfinite(asym{is}));
%    asym2{is}= asym{is}(ind);
%end

%auxCmpDist(asym2, sel, 'Asym', opt);
%auxPlotCDF(asym2, sel, 'Asym', '')
end

% max of power spectrum
%[m,f]= auxCalcPSMax(XC, opt);
%auxCmpDist(f, sel, 'MaxFreq', opt);
%auxPlotCDF(f, sel, 'MaxFreq', opt.scaling)
%auxCmpDist(m, sel, 'MaxPower', opt);
%auxPlotCDF(m, sel, 'MaxPower', opt.scaling)

%m= auxCalcPS(XC, opt);
%auxCmpDist(m, sel, 'power', opt);
%auxPlotCDF(m, sel, 'power', opt.scaling)

% plot all CCG
if(plotall)
    auxPlotCCG(XC, FXC, AUX, opt, sel);
end


%keyboard


function auxCmpDist(x, sel, var, opt)
fprintf(1, '\ncomparing %s\n', var);
nsel= length(x);
for is=1:nsel
    if is==opt.ref | isempty(x{is}); continue; end
    p= ranksum(x{opt.ref}, x{is});
    fprintf(1, 'Ranksum test %s vs. %s p=%.3g.\n', sel{opt.ref}.label, sel{is}.label, p);
    [h,p]= kstest2(x{opt.ref}, x{is});
    fprintf(1, 'KS test %s vs. %s p=%.3g.\n', sel{opt.ref}.label, sel{is}.label, p);
end

function auxHist(x, sel, var, outname)
nsel= length(x);
minx=1e10; maxx= -1e10;
for is=1:nsel; maxx= max([x{is}, maxx]); minx= min([x{is}, minx]); end
b= linspace(minx, maxx, 11);
lstr= {};
for is=1:nsel
    h(:,is)= histc(x{is}', b);
    h(:,is)= h(:,is)/sum(h(:,is));
    lstr{is}= sel{is}.label;
end
figure
%plot(b(1:end-1)+(b(2)-b(1))/2, h(1:end-1,:));
bar(b+(b(2)-b(1))/2,h);
legend(lstr, 0);
xlabel(var);
myprint('large', ['hist_' var '_' outname]);

function auxPlotCDF(x, sel, var, outname)
figure
plotcol= {'k', 'r', 'b', 'g', 'm', 'y', 'c', 'r', 'k'};
lstr= {};
nsel= length(x);
il= 0;
for is=1:nsel
    if isempty(x{is}); continue; end
    h= cdfplot(x{is});
    set(h, 'Color', plotcol{is});
    il=il+1;
    lstr{il}= sel{is}.label;
    hold on
end
legend(lstr, 0);
xlabel(var);
ylabel('cum. fraction');
title('');
figname= [var '_' outname];
set(gcf, 'Name', figname);
myprint(2.5*[1 2/3], figname);

function asym= auxCalcAsym(x, opt, aux)
nsel= length(x);
for is=1:nsel
    np= size(x{is}, 2);
    for ip=1:np
        y= x{is}(:,ip);
        t= aux{is}.lags*opt.dt;
        ind= find(t>-0.07 & t<=0);
        r1= sum(y(ind));

        ind= find(t>0 & t<=0.07);
        r2= sum(y(ind));

        asym{is}(ip,:)= (r2-r1)/(r1+r2);
    end
end
%keyboard

function [lp,dPF]= auxCalcPeakLoc(x, opt, aux, dPF)
nsel= length(x);
traj_fac=-[1 -1 1 -1];
fct= inline('b(1)*exp(-0.5*(x-b(2)).^2/b(3))', 'b', 'x');
for is=1:nsel
    M= (length(aux{is}.lags)-1)/2;
    np= size(x{is}, 2);
    for ip=1:np

        y= x{is}(:,ip);
        t= aux{is}.lags*opt.dt;

%        d= dPF{is}(ip)*traj_fac(aux{is}.pairlist.traj{ip}+1);

%        b= nlinfit(t,y, fct, [1 0 1]);
%        [mbig,i]= max(fct(b,t));
%        dPF{is}(ip)= 1000*t(i);
%        d= dPF{is}(ip);


%        if d>=0
%            ind= find(t>-0.01 & t<=0.130)';
%            fac=1;
%        else
%            ind= find(t>-0.13 & t<0.01)';
%            fac=-1;
%        end

        ind= find(t>=-0.10 & t<=0.10)';
%        ind= find(t>-0.05 & t<=0.05)';
        fac=1;

%        [m,i]= max(y(ind));
%        lp{is}(ip)= 1000*t(ind(i));

        % find peaks
        ipeaks= ind(findPeaks(y(ind)'));
        if isempty(ipeaks); 
            lp{is}(ip)= nan; %%@@
        else
            [m,i]= max(y(ipeaks));
            lp{is}(ip)= (ipeaks(i)-M-1)*opt.dt*1000;
        end


%            fprintf(1, 'dPF %.1f, d= %.1f, traj= %d\n', ...
%                dPF{is}(ip), d,aux{is}.pairlist.traj{ip});
%            plot(t, y);
%            hold on
%            plot(lp{is}(ip)/1000, m, 'bo');
%            plot(t, fct(b,t),'r');
%            plot(dPF{is}(ip)/1000, mbig,'ro');
%            hold off
%            set(gca,'xlim', [-.13 .13]);
%            pause

%        dPF{is}(ip)= abs(d);
%        lp{is}(ip)= abs(lp{is}(ip));
%        dPF{is}(ip)= fac*(d);
        lp{is}(ip)= fac*(lp{is}(ip));
    end
end
%keyboard


function pr= auxCalcPeakIndex(x, dt, lags)
M= (length(lags)-1)/2;
% interval of preceding, central, and following theta cycle
tb=[-.1875, -.0625, .0625, .1875];
ti= floor(tb/dt)+M+1;
for j=1:3
    ind{j}= [ti(j):ti(j+1)];
end
nsel= length(x);
for is=1:nsel
    np= size(x{is}, 2);
    for ip=1:np
        % find peaks
        for j=1:3
            [m(j), l(j)]= max(x{is}(ind{j},ip));
        end
        av= (m(1)+m(3))/2;
        pr{is}(ip)= (m(2)-av)/(m(2)+av);
    end
end

function auxCut(x, sel, cut, var)
nsel= length(x);
n= zeros(nsel, 2);
frac= zeros(nsel, 2);
for is=1:nsel
    n(is,1)= sum(x{is}<cut);
    n(is,2)= sum(x{is}>cut);
    frac(is,:)= n(is,:)/sum(n(is,:));
end
frac

% bootstrap analysis
reps= 10000;
ref= 1;
n1= length(x{ref});
f1= zeros(reps, 2);
for r=1:reps
    ind= floor(n1*rand(n1,1))+1;
    xb= x{ref}(ind);
    tmp(1)= sum(xb<cut);
    tmp(2)= sum(xb>=cut);
    f1(r,:)= tmp/n1;
end

for is=1:nsel
    p= sum(f1(:,2)>= frac(is,2))/reps;
    fprintf(1, 'bootstrap test %s vs. %s p=%.3f.\n', sel{1}.label, sel{is}.label, p);
end

function auxPlotCCG(xc, fxc, aux, opt, sel)
figure
nsel= length(xc);
olddir= pwd;

for is=1:nsel
    clf
    hold on
    workdir= sprintf('%s/work/CCG/%s/%s/%s', ...
        opt.root, sel{is}.pairsel, sel{is}.spsel, sel{is}.selectid);
    cd(workdir)
    np= size(xc{is},2);
    pl= aux{is}.pairlist;
    T= aux{is}.lags(end)*opt.dt;
    t= opt.dt*aux{is}.lags';
    nt= length(t);
    for ix=1:np
        ip= aux{is}.ix(ix);

%        if(ip~=67); continue; end %%@@
%            ix

%        if ~((is==1 & ip==12) | (is==2 & ip==5)); continue; end

%        plot(t, [xc{is}(:,ix),fxc{is}(:,ix)]);
        plot(t, fxc{is}(:,ix));

%        [b,bint,r,rint,stats]= regress(xc{is}(:,ix), [t ones(nt,1)]);
%        hold on
%        plot(t,b(1)*t+b(2), 'k');
%        hold off


        set(gca, 'XLim', [-T, T]);
        set(gca, 'YLim', [0 max(fxc{is}(:,ix))]);
        num= pl.cellnum(ip,:);
        tstr= sprintf('%s: %d %d %d %d', pl.rat{ip}, num(1:4));
        fnstr= sprintf('%s-%d-%s-%d-%d-%d-%d', sel{is}.label, ip, pl.rat{ip}, num(1:4));
        if(length(num)>4)
            tstr= sprintf('%s, %d %d', tstr, num(7:8));
            fnstr= sprintf('%s__%d-%d', fnstr, num(7:8));
            ylabel('cross correl.');
        else
            ylabel('auto correl.');
        end
        if isfield(pl, 'traj')
            tstr= [tstr '; traj '];
            trajs=  pl.traj{ip};
            for itraj=1:length(trajs)
                tstr= sprintf('%s %d', tstr, trajs(itraj));
            end
        end
%        title(tstr);
        xlabel('time lag (sec)');
        myprint('mini', fnstr);
    end
end
cd(olddir)

function [m,f]= auxCalcPSMax(x, opt)
nsel= length(x);
for is=1:nsel
    np= size(x{is}, 2);
    for ip=1:np
        y= x{is}(:,ip);
%        y= y-mean(y);
        % normalize
%        if mean(y.^2) > 0
%            y= y/sqrt(mean(y.^2));
%        end
%        if mean(y) > 0
%            y= y/mean(y);
%        end
%        [Px,freq] = pwelch(y,ip),[],[],[],1/opt.dt);
        [Px, freq] = pmtm(y,[],[],1/opt.dt,'eigen');
        % find peaks
        i= findPeaks(Px');
        [tmp, imin]= min(abs(freq(i)-8));
        m{is}(ip)= Px(i(imin));
        f{is}(ip)= freq(i(imin));
    end
end

function m= auxCalcPS(x, opt)
nsel= length(x);
for is=1:nsel
    disp(is);
    np= size(x{is}, 2);
%    for ip=[27,35]  % 27, 35
    for ip=1:np
        y= x{is}(:,ip);
%        if sum(y) > 1e-2
%            y= y/mean(y);
%        end
%        y= y-mean(y);
        % normalize
%        if mean(y.^2) > 0
%            y= y/sqrt(mean(y.^2));
%        end
%        [Px,freq] = pwelch(x{is}(:,ip),[],[],[],1/opt.dt);
        [Px, freq] = pmtm(y,[],[],1/opt.dt,'eigen');

%        hold off
%        semilogy(freq, Px);
%        set(gca, 'XLim', [0,100]);
%        i= findPeaks(Px');
%        hold on
%        semilogy(freq(i), Px(i), '.');
%        pause

        % normalize
%        ind= find(1<freq & freq<100);
%        if sum(Px(ind))>0;
%            Px= Px/sum(Px(ind));
%        end

        % get power in theta band
%        ind= find(freq<6);
        ind= find(6<freq & freq<10);
%        ind= find(11<freq & freq<100);
        m{is}(ip)= sum(Px(ind));
    end
end


function d= auxGetDistancePF(pl,opt)
np= length(pl.rat);
d= zeros(np,1);
traj_fac=-[1 -1 1 -1];

if(0)
    for ip=1:np
        d(ip)= mean(pl.pf{ip}(3:4))- mean(pl.pf{ip}(1:2));
        d(ip)= traj_fac(pl.traj{ip}+1)*d(ip);
    end
else 
    olddir= pwd;
    ind=[1:4; 5:8];
    indPF=[1:2; 3:4];
    for ip=1:np
        if ip==1 | ~strcmp(pl.rat{ip}, pl.rat{ip-1})
            cd(sprintf('%s/%s/data2/', opt.root, pl.rat{ip}));
            load rate
            setLocalOptions
        end
        for j=1:2
            num= pl.cellnum(ip,ind(j,:));
            rdata= rate{num(1)}{num(2)}{num(3)}{num(4)}.data;
            traj= pl.traj{ip};
            x= pl.pf{ip}(indPF(j,1)):1:pl.pf{ip}(indPF(j,2));
            r= interp1(rdata(:,1), rdata(:,traj+2), x, 'linear');
            cent(j)= sum(r.*x)/sum(r);
        end
        d(ip)= traj_fac(pl.traj{ip}+1)*diff(cent);
    end
    cd(olddir);
end


function auxPlotTwoVar(x,y,opt,sel)
nx= length(x);
if nx~= length(y); 
    error('  The two variables have different number of sets.');
end
plotcol= {'c', 'm', 'y', 'c', 'r', 'b', 'g'};
for i=1:nx
    figure
    fprintf(1, '%s, \t', sel{i}.label);
    opt.plotcol= plotcol{i};
    [p(i), r(i), n(i)]= linrel(x{i}, y{i}, opt, 0.05);
    hold on
    myprint('mini', ['seq_comp_' opt.id '_' sel{i}.label]);
end
%myprint('small', [opt.yvar '-vs-' opt.xvar]);

z= 0.5*log((1+r)./(1-r));

if n(opt.ref)<4; error('need more than 3 data points for testing corr'); end
for i=1:nx
    if i== opt.ref; continue; end
    if n(i)<4; warning('skipping test (less than 4 datapoints)'); end
    Z= (z(i)-z(opt.ref))/sqrt(1/(n(i)-3)+1/(n(opt.ref)-3));
    if Z>0; Z=-Z; end
    pval= normcdf(Z)*2;
    fprintf(1, '  "%s" vs. "%s": p=%.3f\n',  sel{opt.ref}.label, sel{i}.label, pval);
end


function d= auxGetOverlapPF(pl,opt)
np= length(pl.rat);
d= zeros(np,1);
for ip=1:np
    x= reshape(pl.pf{ip},2,2);
    ol= [max(x(1,:)) min(x(2,:))];
%    d(ip)= 2*diff(ol)/(sum(diff(x)));
    d(ip)= diff(ol);

%    d(ip)= abs(diff(mean(x))); % distance between centers
%    d(ip)= diff(x(1,:)); % distance between centers

%    d(ip)= abs(diff(mean(x))) / mean(diff(x)); % distance between centers, norm
%    by width
end

function [rs, Rsq]= auxCalcRegSlope(x, opt, aux)
nsel= length(x);
for is=1:nsel
    t= aux{is}.lags'*opt.dt;
    nt=length(t);
    np= size(x{is}, 2);
    for ip=1:np
        [b,bint,r,rint,stats]= regress(x{is}(:,ip), [t ones(nt,1)]);
%        fprintf(1,'%.4g\n', stats(3));
%        rs{is}(ip,:)= abs(b(1));
        rs{is}(ip,:)= b(1);
        Rsq{is}(ip,:)= stats(1);

%        plot(t,x{is}(:,ip))
%        hold on
%        plot(t,b(1)*t+b(2), 'k');
%        hold off
%        pause
    end
end

%function [rs, Rsq]= auxCalcRegSlope(x, opt, aux)
%figure
%nsel= length(x);
%for is=1:nsel
%    t= aux{is}.lags'*opt.dt;
%    nt=length(t);
%    np= size(x{is}, 2);
%    for ip=1:np
%        y= x{is}(:,ip);
%        i=findPeaks(-y');
%        n=length(i);
%        [b,bint,r,rint,stats]= regress(y(i), [t(i) ones(n,1)]);
%        rs{is}(ip,:)= abs(b(1));
%        rs{is}(ip,:)= b(1);
%        Rsq{is}(ip,:)= stats(1);

%        plot(t,y);
%        hold on
%        plot(t,b(1)*t+b(2), 'k');
%        plot(t(i), y(i), 'ro');
%        hold off
%        pause
%    end
%end

function area= auxCalcCCGArea(x, opt, aux)
nsel= length(x);
for is=1:nsel
    np= size(x{is}, 2);
    dt= aux{is}.lags*opt.dt;
    ind= find(dt>-0.7 & dt<0.7);
    for ip=1:np
        area{is}(ip,:)= sum(x{is}(ind,ip))*opt.dt;
    end
end

