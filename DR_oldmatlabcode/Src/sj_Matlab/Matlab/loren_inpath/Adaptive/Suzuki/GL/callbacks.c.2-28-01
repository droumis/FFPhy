#include <stdlib.h>
#include <unistd.h>
#include <math.h>
#include <GL/glut.h>
#include <GL/glu.h>
#include <GL/gl.h>
#include "adapt.h"

#define NTHETAP 10

/* global variables */
float epsilon[3];
float mle[3];
float stdev[3];
int    rtxi;
int    rtti;
int rti;
int eti;
int posi;
int    rtxinc;
int    rttinc;
int    etinc;
int    posinc;
int animate, grid;
int currentspeed;
float *rattime;
float starttime;
float *ratpos;
float *esttheta;
float *cpx;
float *cpt;
float *thetacurrx;
float *thetacurrt;
float *realcpx;
float *realcpt;
float *realthetax;
float *realthetat;
float *realthetacurrx;
float *realthetacurrt;
float *spiketime;
float *currentspike;
float *spikepos;
float *spikeisi;
float timestep;
float lastspiketime = 0;
float spiket = 0;

int nsamples;
int nspikes;
int    nspikestmp = 0;
int ncpx;
int ncpt;
int realncpx;
int realncpt;
int    interpspline = 0;
int nrthetaparms;
float    leftwall;
float    rightwall;
float    traj2start;
float    peakratex;
float    peakratet;

typedef struct _WindowLocations {
    float bottom;
    float tbottom;
    float ttop;
    float xbottom;
    float xtop;
    float top;
} WindowLocations; 

WindowLocations winloc;

/* get points from files */

void Init(void) {
    
    int i, j;
    int nelem;    
    /* read in the times of the spikes */
    nsamples = getnelements(info.ratposfile, sizeof(float));
    nspikes = getnelements(info.spikefile, sizeof(float));

    printf("\nScanning input files "); fflush(stdout);

    nelem = getnelements(info.estthetafile, sizeof(float));
    esttheta = (float *) malloc(sizeof(float) * nelem);
    readdata(info.estthetafile, esttheta, nelem);
    /* the first two values of estthetafile are the number of x control points and the
     * number of t control points */
    ncpx = round(esttheta[0]);
    ncpt = round(esttheta[1]);
    cpx = esttheta+2;
    cpt = cpx + ncpx;
    /* the start of the second trajectory is the middle control point */
    traj2start = cpx[(int) ncpx/2]; 
    /* thetacurrx is the current array of x control point heights */
    thetacurrx = (float *) malloc(sizeof(float) * ncpx);
    /* thetacurrt is the current array of t control point heights */
    thetacurrt = (float *) malloc(sizeof(float) * ncpt);
    /* copy the starting values into cpx and cpt */
    for (i = 0; i < ncpx; i++) {
        thetacurrx[i] = esttheta[2+ncpx+ncpt+i];
    }
    for (i = 0; i < ncpt; i++) {
        thetacurrt[i] = esttheta[2+2*ncpx+ncpt+i];
    }
    /* advance the pointer past the control point initial values */
    esttheta = esttheta + 2 * (1 + ncpx + ncpt);    
    

    /* if this is to be compared to simulated data, read in the data */
    if (info.simdata) {
        /* start with the x control points */
        nelem = getnelements(info.realthetaxfile, sizeof(float));
        realthetax = (float *) malloc(sizeof(float) * nelem);
        readdata(info.realthetaxfile, realthetax, nelem);
        /* the first value is the number of x control points */
        realncpx = round(realthetax[0]);
        realcpx = realthetax+1;
        /* increment realthetax to start at the beginning of the data. Note that this
         * leaves a memory hole of 1 element */
        realthetax = realthetax + (1 + realncpx);
        /* check the size of realthetax. If it contains only two columns of data, we need
         * to interpolate between those two columns to get the appropriate values at each
         * time step */

        /* do the t control points */
        nelem = getnelements(info.realthetatfile, sizeof(float));
        realthetat = (float *) malloc(sizeof(float) * nelem);
        readdata(info.realthetatfile, realthetat, nelem);
        /* the first value is the number of x control points */
        realncpt = round(realthetat[0]);
        realcpt = realthetat+1;
        /* increment realthetax to start at the beginning of the data. Note that this
         * leaves a memory hole of 1 element */
        realthetat = realthetat + (1 + realncpt);

        /* check the size of realthetat. If it contains only two columns of data, we need
         * to interpolate between those two columns to get the appropriate values at each
         * time step */
        if (nelem == 1 + realncpt * 3) {
            interpspline = 1;
            /* allocate space for the realthetacurrx and realthetacurrt arrays */
            realthetacurrx= (float *) malloc(sizeof(float) * realncpx);
            realthetacurrt = (float *) malloc(sizeof(float) * realncpt);
            for (i = 0; i < realncpx; i++) {
                realthetacurrx[i] = realthetax[i];
            }
            for (i = 0; i < realncpt; i++) {
                realthetacurrt[i] = realthetat[i];
            }
        }
        else {     
            realthetacurrx = realthetax;
            realthetacurrt = realthetat;
        }
    }

    rattime = (float *)malloc(sizeof(float)*nsamples);
    ratpos = (float *)malloc(sizeof(float)*nsamples);

    spiketime = (float *)malloc(sizeof(float)*nspikes);
    spikepos = (float *)malloc(sizeof(float)*nspikes);
    spikeisi = (float *)malloc(sizeof(float)*nspikes);

    readdata(info.ratposfile, ratpos, nsamples);
    printf(" . ");
    readdata(info.timefile, rattime, nsamples);
    starttime = rattime[0];
    printf(" . ");
    readdata(info.spikefile, spiketime, nspikes); 
    printf(" . ");
    printf(" . ");
    printf("Done , nspikes = %d\n", nspikes); fflush(stdout);


    leftwall = cpx[0];
    rightwall = traj2start;
    peakratex = -1e100;
    peakratet = -1e100;

    for (i = 0; i < nsamples; i++) {
        for (j = 1; j < 5; j++) {
            if (exp(esttheta[i*NTHETAP+j]) > peakratex) {
                peakratex = exp(esttheta[i*NTHETAP+j]); 
            }
        }
        for (j = 6; j < 10; j++) {
            if (exp(esttheta[i*NTHETAP+j]) > peakratet) {
                peakratet = exp(esttheta[i*NTHETAP+j]); 
            }
        }
    }
    

    printf("Found peak values: %f, %f\n", peakratex, peakratet); fflush(stdout);

    /* set up the locations for the various sections of the display */
    winloc.bottom = -1 * BELOW_T_HEIGHT;
    winloc.tbottom = 0;
    winloc.ttop = winloc.tbottom + T_HEIGHT;
    winloc.xbottom = winloc.ttop + ABOVE_T_HEIGHT;
    winloc.xtop = winloc.xbottom + X_HEIGHT;
    winloc.top = winloc.xtop + ABOVE_X_HEIGHT;
    /* define grid */
    define_grid();

    currentspike = spiketime;
    
    rtxi = 0;
    rtti = 0;
    eti = 0;
    posi = 0;
    animate = 1;
    grid = 1;

    currentspeed = 10;
    rtxinc = realncpx * currentspeed;
    rttinc = realncpt * currentspeed;
    etinc = NTHETAP * currentspeed;
    posinc = currentspeed;
    timestep = rattime[4]-rattime[3];
    glEnable(GL_POINT_SMOOTH);

}


/* display function */
void Display(void) {
    
    int i;
    int cseg;

    glClear(GL_COLOR_BUFFER_BIT);
    
    draw_grid(); 
    drawgridlabels();
    
    if (info.simdata) {
        if (interpspline) {
            calctheta(realncpx, realncpt, realthetax, realthetat, (float) posi / 
                      (float) nsamples, realthetacurrx, realthetacurrt);
        }
        drawfieldx(realcpx, realthetacurrx, realncpx, 1.0, 1.0, 0, 1, 1, 0);  
        drawfieldt(realcpt, realthetacurrt, realncpt, 1.0, 1.0, 0);  
    }
    drawfieldx(cpx, thetacurrx, ncpx, 1.0, .6, .2, 1.0, 1.0 , 0.3 ); 
    drawfieldt(cpt, thetacurrt, ncpt, .3, 1.0, 1.0); 
    drawrat();
    /* do drawspikes for each timestep */
    drawspikes();
    drawtime();  

    if (ratpos[posi] == 0) {
        posi = posi;
    }
    
    glutSwapBuffers();
    
    if((posi < (nsamples-2-posinc))&&(animate == 1)) {
        /* update the current thetahat */
        for (i = 0; i < round((double) etinc / (double) NTHETAP); i++) {
            if ((cseg = esttheta[eti+i*NTHETAP]) != -1) {
                thetacurrx[cseg-1] = esttheta[eti+i*NTHETAP+1];
                thetacurrx[cseg] = esttheta[eti+i*NTHETAP+2];
                thetacurrx[cseg+1] = esttheta[eti+i*NTHETAP+3];
                thetacurrx[cseg+2] = esttheta[eti+i*NTHETAP+4];
            }
            /* update the points on the end if necessary */
            if (cseg == 1) {
                thetacurrx[ncpx-2] = thetacurrx[0];
                thetacurrx[ncpx-1] = thetacurrx[1];
            }
            else if (cseg == ncpx - 3) {
                thetacurrx[0] = thetacurrx[ncpx-2];
                thetacurrx[1] = thetacurrx[ncpx-1];
            }
            if ((cseg = esttheta[eti+i*NTHETAP+5]) != -1) {
                thetacurrt[cseg-1] = esttheta[eti+i*NTHETAP+6];
                thetacurrt[cseg] = esttheta[eti+i*NTHETAP+7];
                thetacurrt[cseg+1] = esttheta[eti+i*NTHETAP+8];
                thetacurrt[cseg+2] = esttheta[eti+i*NTHETAP+9];
            }
        }
        eti += etinc;
        posi += posinc;
        if (info.simdata) {
            /* increment the pointers to the current real theta hats */
            rtxi += rtxinc;
            rtti += rttinc;
            if (interpspline) {
                calctheta(realncpx, realncpt, realthetax, realthetat, (float) posi / 
                          (float) nsamples, realthetacurrx, realthetacurrt);
            }
            else {
                realthetacurrx = realthetax + rtxi;
                realthetacurrt = realthetat + rtti;
            }
        }
    }
    else {
    	usleep(250000);
    }
}

/* change camera when window is resized */
void Reshape(int w, int h) {
    
    int extrasize = (rightwall - leftwall) / 8;
    
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(leftwall-extrasize, rightwall+extrasize, winloc.bottom, winloc.top, -1000, 1000);
    glViewport(0, 0, w, h);
    glMatrixMode(GL_MODELVIEW);
    
}


void drawfieldx(float *cpx, float *cpy, int ncpx, float r1, float g1, float b1, float r2, 
		float g2, float b2) 
{

    float lambdax[300];
    float lambday[300];
    float xstep;
    int i;
    
    xstep = (rightwall - leftwall)/200.0f;
    glColor3d(r1, g1, b1);
    glLineWidth(3.0f);
    
    for(i = 0; i < 200; i++) {
        lambdax[i] = leftwall + i * xstep;
    }
    cardinal(cpx, cpy, ncpx, lambdax, lambday, 200);
    
    glBegin(GL_LINE_STRIP);
    for(i = 0; i < 200; i++) {
        if ((i > 1) && (lambday[i] - lambday[i-1] > 7)) {
            if (i > 300)
                i--;
        }
        glVertex3f(leftwall + i*xstep, winloc.xbottom + lambday[i],0.0f);
    }
    glEnd();
    
    glColor3d(r2, g2, b2);
    glLineWidth(3.0f);
    
    for(i = 0; i < 200; i++) {
        lambdax[i] = rightwall + i * xstep;
    }
    cardinal(cpx, cpy, ncpx, lambdax, lambday, 200);
    
    glBegin(GL_LINE_STRIP);
    for(i = 0; i < 200; i++) {
        if ((i > 1) && (lambday[i] - lambday[i-1] > 7)) {
            if (i > 300)
                i--;
        }
        glVertex3f(rightwall - i*xstep, winloc.xbottom + lambday[i],0.0f);
    }
    glEnd();

    glLineWidth(1.0f);
    
}

void drawfieldt(float *cpt, float *cpy, int ncpx, float r, float g, float b) {

    float lambdat[200];
    float lambday[200];
    float tmp1;
    float tmp2;
    int npoints = 200;
    int i;
    
    /* plot the temporal spline out to 1 second */
    glColor3d(r, g, b);
    glLineWidth(3.0f);
    
    /*lambdat[0] = 1e-3; */
    for(i = 1; i < npoints; i++) {
        lambdat[i] = (float) pow(10,(float) (i * 3.0 / (float) npoints)) * 0.001; 
    }
    cardinal(cpt, cpy, ncpt, lambdat, lambday, npoints); 
    
    tmp1 = (rightwall - leftwall) / 3; 
    tmp2 = peakratex / peakratet;
    /* scale the lambda to be on a log scale */
    glBegin(GL_LINE_STRIP);
    for(i = 1; i < npoints; i++) {
        glVertex3f(leftwall+log10(lambdat[i]*1e3)*tmp1, winloc.tbottom + lambday[i]*tmp2, 0.0f);
    }
    glEnd();
    
}

int detectspike(int start, int end) {

    int i;
    
    for(i =0; i < nspikes; i++) {
        if((spiketime[i] > rattime[start])&&(spiketime[i] <= (rattime[end]))) {
            return 1;
        }
    }
    
    return 0;
}

void drawgridlabels(void) {

    char     tmpstring[50];
    float    times[] = {1.0, 10, 100, 1000}; 
    float     tmp1, tmp2, middle;
    int     i, j, len;

    tmp1 = (rightwall - leftwall) / 3; 

    glColor3d(1.0,1.0,1.0);
    /* draw the spatial and temporal component labels  and the axis labels*/
    middle = (leftwall + rightwall) / 2;
    sprintf(tmpstring, "Spatial Component");
    len = (int) strlen(tmpstring);
    glRasterPos2f(middle - len*2 , winloc.xtop+10);
    for (j = 0; j < len; j++) {
	glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, tmpstring[j]);
    }
    sprintf(tmpstring, "Temporal Component");
    len = (int) strlen(tmpstring);
    glRasterPos2f(middle-len*2, winloc.ttop-5);
    for (j = 0; j < len; j++) {
	glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, tmpstring[j]);
    }
    sprintf(tmpstring, "(cm)");
    len = (int) strlen(tmpstring);
    glRasterPos2f(middle - len*2 , winloc.xtop+3);
    for (j = 0; j < len; j++) {
	glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, tmpstring[j]);
    }
    sprintf(tmpstring, "ISI (ms)");
    len = (int) strlen(tmpstring);
    glRasterPos2f(middle-len*2, winloc.tbottom-10);
    for (j = 0; j < len; j++) {
	glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, tmpstring[j]);
    }
    
    /* draw the axis labels */

    /* draw the times for the temporal spline */
    tmp2 = (winloc.tbottom + winloc.bottom) / 2;
    for (i = 0; i < 5; i++) {
        switch (i) {
            case 0: 
                sprintf(tmpstring, "%1.1f", times[i]);
                break;
            case 1:
                sprintf(tmpstring, "%2.0f", times[i]);
                break;
            case 2:
                sprintf(tmpstring, "%3.0f", times[i]);
                break;
            case 3:
                sprintf(tmpstring, "%4.0f", times[i]);
                break;
        }

        glRasterPos2f(leftwall+log10(times[i])*tmp1 - 5, tmp2);
        len = (int) strlen(tmpstring);
        for (j = 0; j < len; j++) {
            glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, tmpstring[j]);
        }
    }
    /* draw the 1 on the t spline y axis */
    sprintf(tmpstring, "1.0");
    glRasterPos2f(leftwall - 10, winloc.ttop / peakratet);
    len = (int) strlen(tmpstring);
    for (j = 0; j < len; j++) {
	glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, tmpstring[j]);
    }

    /* label every 100 cm for X spline */
    i = 0;
    while ((tmp2 = leftwall + 100 * i) <= rightwall) {
	glRasterPos2f(tmp2-8, winloc.xtop+4);
	sprintf(tmpstring, "%2.0f", (float) (i++)*100);
	len = (int) strlen(tmpstring);
	for (j = 0; j < len; j++) {
	    glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, tmpstring[j]);
	}
    } 
    /* lines every 10 Hz for X spline */
    i = 0;
    while ((tmp2 = winloc.xbottom + 10 * i) <= winloc.xtop) {
	glRasterPos2f(leftwall - 10, tmp2);
	sprintf(tmpstring, "%2.0f", (float) (i++)*10);
	len = (int) strlen(tmpstring);
	for (j = 0; j < len; j++) {
	    glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, tmpstring[j]);
	}
    } 
 
}

void drawtime(void) {

    char tmpstring[50];
    int len, i;

    sprintf(tmpstring, "%.2f", rattime[posi] - starttime);
    
    glColor3f(1.0,1.0,1.0);
    glRasterPos2f(-27, winloc.xtop+10);
    len = (int) strlen(tmpstring);
    for (i = 0; i < len; i++) {
        glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, tmpstring[i]);
    }

}

void drawrat(void) {

    glEnable(GL_POINT_SMOOTH);
    glPointSize(75.0f);
    glColor3d(1.0,1.0,1.0);

    glBegin(GL_POINTS);
        glVertex3f(ratpos[posi + posinc], winloc.xbottom, 0.0f);
    glEnd();

}

void drawspikes(void) 
{
    int i;
    float tmp1, tmp2, tmp3;

    glColor3d(1.0,0,0);
    /* reset the list if the rat is moving in the negative direction */
    if ((posi < (nsamples-2-posinc)) && (esttheta[eti] == -1)) { 
        nspikestmp = 0;
    }
    for (i = 0; i < posinc; i++) {
        if (detectspike(posi+i, posi+i+1)) { 
            /* add the spike to the spikelist */
            spikeisi[nspikestmp] = rattime[posi+i] - lastspiketime;
            spikepos[nspikestmp++] = ratpos[posi+i]; 
            lastspiketime = rattime[posi+i];
        }
    }
    tmp1 = (rightwall - leftwall) / 3;
    tmp3 = peakratex * -0.1;
    tmp2 = winloc.xbottom + tmp3;
    glLineWidth(0.075f);
    glBegin(GL_LINES);
    for(i = 0; i < nspikestmp; i++) {
        /* draw the position spikes */
        glVertex3f(spikepos[i], winloc.xbottom, 0.0f);
        glVertex3f(spikepos[i], tmp2, 0.0f);
        /* draw the temporal spike */
        glVertex3f(leftwall+log10(spikeisi[i]*1e3)*tmp1, 0, 0.0f);
        glVertex3f(leftwall+log10(spikeisi[i]*1e3)*tmp1, tmp3, 0.0f);
    }

    glEnd();
}

void define_grid() 
{
    int i;
    float tmp;

    glNewList(GRID, GL_COMPILE);
    glColor3f(0,0,1.0);
    glBegin(GL_LINES);
    /* put in one horizontal line at 0 and one at 1 for the temporal spline */
    glVertex3d(leftwall, 0, 0);
    glVertex3d(rightwall, 0, 0);
    /* line at 1 */
    glVertex3d(leftwall, winloc.ttop / peakratet, 0);
    glVertex3d(rightwall, winloc.ttop / peakratet, 0);
    /* line at max of t */
    glVertex3d(leftwall, winloc.ttop, 0);
    glVertex3d(rightwall, winloc.ttop, 0);

    /* lines every 10 Hz for X spline */
    glVertex3d(leftwall, winloc.xbottom, 0);
    glVertex3d(rightwall, winloc.xbottom, 0); 
    i = 0;
    while ((tmp = winloc.xbottom + 10 * i++) <= winloc.xtop) {
        glVertex3d(leftwall, tmp, 0);
        glVertex3d(rightwall, tmp, 0);
    } 
    /* do the vertical lines */
    /* the bottom plot is on a log scale so put grid lines at zero, .001, .01, 
     * .1, 1, and 10. Scale the leftwall to rightwall distances to be from 0.001 to 10
     * seconds on the log scale or 0 to 4 on a linear scale. To do so, multiply each time
     * by 1000, take the log10, and scale from leftwall to right wall */
    tmp = (rightwall - leftwall) / 3; /* 3 segments: .001->.01, .01->.1, .1->1  */
    glVertex3d(leftwall + log10(.001*1e3)*tmp,  0, 0);
    glVertex3d(leftwall + log10(.001*1e3)*tmp, peakratex , 0);
    glVertex3d(leftwall + log10(.01*1e3)*tmp,  0, 0);
    glVertex3d(leftwall + log10(.01*1e3)*tmp, peakratex , 0);
    glVertex3d(leftwall + log10(.1*1e3)*tmp,  0, 0);
    glVertex3d(leftwall + log10(.1*1e3)*tmp, peakratex , 0);
    glVertex3d(leftwall + log10(1.0*1e3)*tmp,  0, 0);
    glVertex3d(leftwall + log10(1.0*1e3)*tmp, peakratex , 0); 
    glVertex3d(leftwall + log10(10*1e3)*tmp,  0, 0);
    glVertex3d(leftwall + log10(10*1e3)*tmp, peakratex , 0); 

    /* the vertical lines on the top are every 10 cm */
    for (i = leftwall; i <= leftwall + rightwall; i+=10) {
        glVertex3d(i, winloc.xbottom, 0);
        glVertex3d(i, winloc.xtop, 0);
    }
        
    glEnd();
    glEndList();
}

void draw_grid(void) {

    if(grid)
        glCallList(GRID);
    else {
        glColor3d(0,1.0,0);
        glBegin(GL_LINES);
        glVertex3d(-20, 0, 0);
        glVertex3d(370, 0, 0);
        glEnd();
    }
}


/* menu callback */
void main_menu(int item) {

    switch(item) {

    case 'r':
        lastspiketime = 0;
        rtxi = 0;
        rtti = 0;
        rti = 0;
        eti = 0;
        posi = 0;
        break;
    case 's':
        animate ^= 1;
        break;
    case 'm':
        grid ^= 1;
        break;
    case 'u':
        currentspeed *= 2;
        rtxinc = realncpx * currentspeed;
        rttinc = realncpt * currentspeed;
        etinc = NTHETAP * currentspeed;
        posinc = currentspeed;
        break;
    case 'd':
        currentspeed /= 2;
        if (currentspeed < 1) {
            currentspeed = 1;
        }
        rtxinc = realncpx * currentspeed;
        rttinc = realncpt * currentspeed;
        etinc = NTHETAP * currentspeed;
        posinc = currentspeed;
        break;
    default:
        break;
    }
}

/* keyboard callback */
void Keyboard(unsigned char key, int x, int y) {


}

void calctheta(int ncpx, int ncpt, float *thetax, float *thetat, float prop, 
                                float *thetacurrx, float *thetacurrt)
        /* prop is equal to the current timestep index / ntimestamps */
{

        int i;

        /* interpolate between the two columns of thetax */
        for (i = 0; i < ncpx; i++) {
                thetacurrx[i] = thetax[i] * (1 - prop) + thetax[ncpx+i] * prop;
        }
        /* interpolate between the two columns of thetat */
        for (i = 0; i < ncpt; i++) {
                thetacurrt[i] = thetat[i] * (1 - prop) + thetat[ncpt+i] * prop;
        }
        return;
}

