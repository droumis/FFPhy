#include <stdio.h>
#include <math.h>
#include <GL/glut.h>
#include <GL/glu.h>
#include <GL/gl.h>
#include "adapt.h"

/* global variables */
float epsilon[3];
float mle[3];
float stdev[3];
int ci;
int animate, grid;
int incr;
float *rattime;
float *ratpos;
float *thetae[5];
float *thetar[5];
float *spiketime;
float *spikepos;
float timestep;

char *ratpos_file = "position.txt";
char *spike_file  = "spikes.txt";
char *theta_file1  = "thetahate.txt";
char *theta_file2  = "thetahatr.txt";
int sample_length;
int spike_length;

/* get points from files */
void Init(void) {
  
  int i, j;
  
  /* define grid */
  glNewList(GRID, GL_COMPILE);
  glColor3d(0,70,0);
  glBegin(GL_LINES);
  for(i = 0; i < 9; i++) {
    glVertex3d(-50, i*10, 0);
    glVertex3d(360, i*10, 0);
  }
  
  for(j = -2; j < 67; j++) {
    glVertex3d(j*10, 0, 0);
    glVertex3d(j*10, 200, 0);
  }
  glEnd();
  glEndList();

  sample_length = read_2col_length(ratpos_file, 0);
  spike_length = read_2col_length(spike_file, 0);

  rattime = (float *)malloc(sizeof(float)*sample_length);
  ratpos = (float *)malloc(sizeof(float)*sample_length);
  for(i = 0; i < 4; i++) {
    thetae[i] = (float *)malloc(sizeof(float)*sample_length);
  }
  for(i = 0; i < 4; i++) {
    thetar[i] = (float *)malloc(sizeof(float)*sample_length);
  }

  spiketime = (float *)malloc(sizeof(float)*spike_length);
  spikepos = (float *)malloc(sizeof(float)*spike_length);

  printf("\nScanning input files "); fflush(stdout);
  read_2col(ratpos_file, ratpos, rattime, sample_length, 0, 0); 
  printf(" . ");
  read_2col(spike_file, spikepos, spiketime, spike_length, 0, 0); 
  printf(" . ");
  read_4col(theta_file1, thetae[0],thetae[1],thetae[2],thetae[3],
	    sample_length, 0, 0); 
  read_4col(theta_file2, thetar[0],thetar[1],thetar[2],thetar[3],
	    sample_length, 0, 0); 
  printf(" . ");
  printf("Done \n"); fflush(stdout);
  
  ci = 7000;
  animate = 1;
  grid = 1;
  incr = 4;
  timestep = rattime[4]-rattime[3];
  glEnable(GL_POINT_SMOOTH);

}


/* display function */
void Display(void) {
  
  glClear(GL_COLOR_BUFFER_BIT );
  
  draw_grid();
  
  draw_real_field(thetae, 255, 0, 255);
  draw_real_field(thetar, 255, 255, 0);
  draw_rat();
  draw_time(); 
  
  glutSwapBuffers();
  
  if((ci < (sample_length-2-incr))&&(animate == 1))
    ci = ci + incr;
}

/* change camera when window is resized */
void Reshape(int w, int h) {
  
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  glOrtho(LEFT_WALL, RIGHT_WALL, BOTTOM, TOP, -1000, 1000);
  glViewport(0, 0, w, h);
  glMatrixMode(GL_MODELVIEW);
  
}


void draw_real_field(float *theta[4], int r, int g, int b) {

  float lambdas[200], temp;
  float xstep;
  int i;
  
  xstep = (RIGHT_WALL - LEFT_WALL)/200.0f;
  glColor3d(r, g, b);
  glLineWidth(3.0f);
  
  for(i = 0; i < 200; i++) {
    temp = exp(theta[3][ci]*(i*xstep-theta[2][ci]));
    lambdas[i] = exp(theta[0][ci] / (1 + temp) -0.5f*theta[1][ci]*(i*xstep-theta[2][ci])*(i*xstep-theta[2][ci]));
  }
  
  glBegin(GL_LINE_STRIP);
  for(i = 0; i < 200; i++) {
    glVertex3f(i*xstep, lambdas[i],0.0f);
  }
  glEnd();
  
  glLineWidth(1.0f);
  
}

int detect_spike(void) {

  int i;
  
  for(i =0; i < SPIKENO; i++) {
    if((spiketime[i] > rattime[ci])&&(spiketime[i] <= (rattime[ci]+timestep))) {
      return 1;
    }
  }
  
  return 0;
}


void draw_time(void) {

	char stimer[50];
	int len, i;

	sprintf(stimer, "%.2f", rattime[ci]);
  
	glColor3d(255,255,255);
	glRasterPos2f(10, 20);
	len = (int) strlen(stimer);
	for (i = 0; i < len; i++) {
		glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, stimer[i]);
	}

}

void draw_rat(void) {

	if(detect_spike()) {
	  glDisable(GL_POINT_SMOOTH);
	  glPointSize(50.0f);
	  glColor3d(255,0,0);
		
	}
	else{
		glEnable(GL_POINT_SMOOTH);
		glPointSize(8.0f);
		glColor3d(255,255,0);
	}

	glBegin(GL_POINTS);
	  glVertex3f(ratpos[ci], 0.0f, 0.0f);
	glEnd();

}

void draw_grid(void) {

	if(grid)
		glCallList(GRID);
	else {
		glColor3d(0,255,0);
		glBegin(GL_LINES);
		glVertex3d(-20, 0, 0);
		glVertex3d(370, 0, 0);
		glEnd();
	}
}


/* menu callback */
void main_menu(int item) {

	switch(item) {

	case 'r':
		ci = 7000;
		break;
	case 's':
		animate ^= 1;
		break;
	case 'm':
		grid ^= 1;
		break;
	case 'u':
		incr ++;
		break;
	case 'd':
		incr --;

		if(incr < 1)
			incr = 1;
		break;
	default:
	
		break;
	}
}

/* keyboard callback */
void Keyboard(unsigned char key, int x, int y) {


}
